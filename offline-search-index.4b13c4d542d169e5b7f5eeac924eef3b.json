[{"body":" blah blah\n","categories":"","description":"","excerpt":" blah blah\n","ref":"/DeNS/docs/","tags":"","title":"DeNS"},{"body":" DeNS Query is implemented with the dens-query-cli executable. In the git repository, it is provided at the flake output packages.\u003csystem\u003e.dens-query-cli, so Nix users can enter a shell with the dens-query-cli executable with the following command.\nnix shell github:mlabs-haskell/DeNS#dens-query-cli When dens-query-cli is executed, it will require that the following dependencies are running:\nPostgreSQL\nOgmios\nMoreover, it will look for a configuration file (see Configuration file format) provided in the environment variable in DENS_QUERY_CONFIG for the relevant dependency connection information along DeNS specific information. Thus, executing dens-query-cli from a shell will often look as follows.\nDENS_QUERY_CONFIG=./path/to/config.json dens-query-cli Configuration file format Users can choose between making dens-query-cli serve HTTP requests on the UNIX domain (via Unix domain sockets) or the Internet domain.\ndens-query-cli serving HTTP requests on the UNIX domain Example configuration file for running dens-query-cli on the UNIX domain { \"ogmios\": (1) { \"url\": \"ws://127.0.0.1:1337\" }, \"database\": (2) { \"user\": \"dens\", \"password\": \"\", \"socket\": { \"name\": \"UnixDomain\", \"fields\": [ { \"path\": \"/var/postgres/\" } ] }, \"database\": \"dens\" }, \"server\": (3) { \"name\": \"UnixDomain\", \"fields\": [ { \"path\": \"/ipc/.s.dens-query\" } ], }, \"protocolNft\": (4) { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } The connection to Ogmios.\nThe connection to a PostgreSQL database.\nThe Unix domain socket that dens-query-cli will serve HTTP requests on.\nThe protocol’s NFT to uniquely identify the DeNS protocol used. The currency_symbol and token_name are hex encoded.\ndens-query-cli serving HTTP requests on the Internet domain Example configuration file for running dens-query-cli on the Internet domain { \"ogmios\": { \"url\": \"ws://127.0.0.1:1337\" }, \"database\": { \"database\": \"dens\", \"password\": \"\", \"socket\": { \"name\": \"UnixDomain\", \"fields\": [ { \"path\": \"/var/postgres/\" } ] }, \"user\": \"dens\" }, \"server\": (1) { \"name\": \"InternetDomain\", \"fields\": [ { \"host\": \"127.0.0.1\", \"port\": \"6969\", } ], }, \"protocolNft\": { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } The host and port that dens-query-cli will serve HTTP requests on.\n","categories":"","description":"","excerpt":" DeNS Query is implemented with the dens-query-cli executable. In the …","ref":"/DeNS/docs/dens-query/getting_started/","tags":"","title":"Getting Started"},{"body":"Requirements (Conceptual) The DeNS protocol must support a small list of essential features to deliver on the promise of a decentralized, transparent, censorship-resistant, and privacy-conscious successor to the DNS protocol. These features are:\nRecords must be stored in an immutable, permanent, and public database. Users must have the ability (at least in principle) to resolve queries locally - that is, it ought to be possible for a user to reconstruct the DeNS database solely from public information, and use that database to resolve queries without sharing those queries (or the identity of the user) with any third party Users must be provided with direct control over their records, such that they can update those records without the assent or intervention of any third party. Users must have the ability to transfer ownership of their records without the assent or intervention of any third party. It must be possible to reconstruct a database, suitable for use as the primary database mapping domain names to resources in a DNS resolver, from these public records A viable and orderly transition path from traditional DNS must exist, such that existing users of DNS can gradually migrate to the DeNS protocol The last feature requires further elaboration and discussion. A ’transition path’, for the purposes of this document, can be understood in two ways: First, from the perspective of end-users of the system, a DeNS transition path requires that they be able to interact with DeNS to resolve traditional DNS queries while benefiting from the advantages of decentralization, transparency, etc. Second, from the perspective of (DNS) domain owners and operators, a transition path requires that DeNS (temporarily) delegates authority over existing DNS records to the authoritative sources of those records in the existing DNS system.\nAs far as we can determine, the only way to delegate authority over existing DNS records to their authoritative source in traditional DNS without abandoning some other required feature is to mirror existing DNS records in the DeNS system. This entails a further design constraint: It must be economically feasible to perform DNS record mirroring in DeNS. While this is, in some sense, an implementation detail, it is nevertheless an essential requirement which must guide the rest of the design.\nOverview: A Cross-Chain Database (Conceptual) The constraints outlined in the previous section give rise to an apparent dilemma: The Web3 technologies which are most suitable for the data-storage functionality (Arweave, IPFS, other distributed storage solutions) are inadequate for implementing the transaction logic, while, conversely, the Web3 technologies most suited to implement transaction logic necessary for users to have meaningful control over their records (Cardano and other smart-contract capable blockchains) are unsuitable for storing the large (relative to typical smart contracts) amounts of data necessary for a protocol that aims to replace DNS in its entirety.\nFortunately, this dilemma only poses a problem under the assumption that the database of DeNS records must exist “in one place”. Were that the case, we would be forced to choose between two unsatisfactory and cumbersome solutions: Either we would have to implement complex smart contract logic on a platform designed primarily for data storage, or implement data storage on a platform designed for contract logic. This assumption, however, is false. If we think of a database as an abstract structure that (logically) associates values (or sets of values) with specific keys, it is clear that a logical relation can be established between keys and values located on entirely distinct Web3 technologies.\nThis insight motivates the general architecture of the DeNS (onchain) protocol: DeNS will consist in a cross-chain database, such that contract logic (creating, updating, deleting, transferring ownership of) records is performed on a smart-contract capable blockchain, while data-storage is performed on a blockchain (or similar Web3 technology) designed for efficient storage and retrieval of data. Transactions on the smart-contract blockchain do not contain records as such (“inline”), but rather contain pointers (references, addresses) to resources on the data-storage Web3 platform. When constructing the database of records to be used in a resolver, transactions on the smart-contract blockchain serve as a source of authorization - only those records which are properly referenced in a suitable transaction on the smart-contract blockchain will be retrieved from the data-store and included in the final data set.\nRoot Domain Topography (Conceptual) Before moving to a detailed discussion of the DeNS protocol architecture, it is necessary to first clarify exactly what is meant (conceptually) by “names” and “records” - and, perhaps most importantly, by “ownership” - in DeNS. To motivate this discussion, it will be helpful to look at the format of a DNS record, here represented as a Haskell data type (we ignore the inner structure of DNS names and resource data here, as these are not important at this level of discussion):\ndata DNSRecord = DNSRecord { name :: DNSName, type :: Word16, class :: Word16, ttl :: Word32, rdLength :: Word16, rData :: ResourceData } Although it is commonplace (and perfectly fine in most circumstances) to think of DNS records as representing a mapping from a human-readable name to a machine-readable IP address, this is not strictly correct. The class field in a DNS record indicates the protocol that the record is concerned with, and one must know the class in order to interpret the type field (and consequently the rData field as well). In almost every interaction with DNS, the class can be assumed to be 1, which indicates an IP (Internet Protocol) record (A,AAAA,MX, etc) - the family of records with which most developers are familiar.\nWhile this may seem like a minor technical detail, it motivates several important questions about the nature of ownership, names, and records in DeNS. Because DeNS aims to support both “traditional DNS records” (which we can now operationally define as: IP class records of types specified in the relevant DNS RFCs) and new classes of records that support a variety of Web3 naming protocols, we cannot maintain the illusion that all records are IP class records. Furthermore, if we wish to sell access rights for the records associated with a given name, we must be able to specify precisely the criteria by which a record is “associated with a given name”. That is: We must be able to tell our potential customers exactly what it is they are buying.\nWe anticipate that, in the future, DeNS will support a variety of name systems. Some of them may integrate with DeNS at a deep level, such that transactions are always processed by a DeNS contract. However, we would also like to support (name resolution for) autonomous protocols which are not managed by DeNS contracts and therefore cannot assume that a single name (i.e. the value of the name field) is owned by the same entity in each supported protocol. Consequently, in DeNS, “ownership” must mean: Delegated control over the records associated with a (Name,Class) pair, where a record R is associated with a name/class pair (N,C) iff R.name == N \u0026\u0026 R.class == C.\nSimilarly, at the highest level there are no “bare names” in DeNS. A DeNS name exists in a Name-Universe which is indicated by the associated class (or, if you prefer, by the protocol the class refers to).\nRecords in DeNS, then, are just ordinary DNS records. However, in order to maximize the number of additional protocols that DeNS support, and to reduce the burden of supporting obsolete protocols, we will consider all existing DNS record classes other than 1 (IP) to be deprecated. We will not consider ourselves obliged to support these protocols, and we reserve the right to reassign their class identifier at our discretion.\nThe considerations raised in this section also constrain the logical structure of the DeNS root domain. In particular, the DeNS root domain must be universal in a sense in which the DNS root domain is not. To elaborate: What we ordinarily refer to as the DNS root domain - the set of zone files served by DNS root servers - is really a DNS root domain. Namely, it is the root domain for the IP class. There are other root domains for non-IP classes, and (e.g.) the Chaosnet root domain and the IP root domain are utterly distinct from one another. In this sense, the existing DNS root domain is not universal.\nDeNS, by contrast, will be universal. Concretely, this implies that the records which constitute the DeNS top-level root domain will contain resources which are associated with a class, and not, as with DNS, a top-level domain. In this way, we can support a wide variety of different protocols, including protocols that serve as their own autonomous top-level domain.\nThis architecture allows us to specify more clearly the mechanics of the transition away from DNS as an authority for IP records: We will lease the IP class of domains to ourselves and maintain mirrors of DNS records until DeNS adoption reaches a level that we judge sufficient to facilitate a “hard fork” from DNS authority. At that point, we will let the lease expire and IP class domains in DeNS will be directly managed by domain owners via DeNS smart contracts.\nArchitecture - Cardano (Technical) (WIP) TODO/FIXME: Everything here assumes that domain ownership is eternal/indefinite. In practice that won’t work, and we’ll have to modify this design to accommodate a “lease” model instead of a “permanent control” model.\nProtocol NFT All contract scripts will be parameterized by a Protocol NFT that uniquely identifies a UTxO which as datum contains the configuration (trusted knowledge of Plutus scripts) of the protocol. More precisely, the Protocol NFT must be paid to an unspendable validator, say ProtocolValidator, which has the following as datum.\ndata Protocol = Protocol { elementIdMintingPolicy :: ScriptHash , setElemMintingPolicy :: ScriptHash , setValidator :: ScriptHash , recordsValidator :: ScriptHash } DISCUSSION: The Protocol NFT acts as a single source of truth for the protocol. This is advantageous because of the following.\nIt allows one to easily refer to other Plutus scripts within the protocol without the worry of cyclic dependencies. It gives the a trustless setup since every Protocol NFT must be paid to the unspendable validator ProtocolValidator, so participants may verify offchain that the datum Protocol is “as expected” without the need to scan through all transactions in the blockchain. If one may extends the ProtocolValidator to be spent under controlled conditions, then since the Protocol NFT acts as the single source of truth, one may effectively update the protocol dynamically. Record Keys and Values Morally, the DeNS protocol is a cross-chain distributed Key-Value store, where the key component is a (Name,Class) pair managed by a Cardano smart-contract, and the value is a pointer to an Arweave resource which in turn contains a set of records.\n{- This data type contains all of the elements necessary to function as a key in our logical database. -} data DeNSKey = DeNSKey { densName :: ByteString -- ^ A human readable domain name , densClass :: Word16 -- ^ Each set represents a Name Universe and must be tagged w/ the class ID corresponding to that universe } -- By convention, this should be an Arweave resource address. `Nothing` indicates a deleted record newtype DeNSValue = DeNSValue { densPointer :: Maybe ByteString } Note that DeNSKeys may be ordered by defining DeNSKey n1 c1 \u003c= DeNSKey n2 c2 iff (n1, c1) \u003c= (n2, c2) i.e., DeNSKeys are ordered lexicographically using the lexicographical ordering of ByteString and the natural ordering of Word16s.\nSet Validator / ELEMENTID Minting Policy The most important invariant that the protocol must maintain is the uniqueness of names in the set of onchain keys. Unfortunately, we cannot adopt the naive approach of using an onchain List to represent this set. Because such a list could conceivably grow to include tens of millions (or more!) entries, and because traversing a list that large would assuredly exceed Cardano ExUnit limits, we are forced to adopt a more sophisticated solution. First, we will require a data type to represent entries in our set:\ndata SetDatum = SetDatum { key :: DeNSKey -- ^ This entry's key , next :: DeNSKey -- ^ The successor to key } SetElemID Minting Policy The SetValidator locks UTxOs containing SetDatum entries and is used alongside with SetElemID to represent the on-chain collection of unique keys. We initialize the set by locking a UTXO with SetDatum (DeNSKey \"\" 0) (DeNSKey ub (2^16 - 1) at the validator (which can be assumed to exist for validation checks) when minting Protocol NFT (to ensure uniqueness of the linked list) where ub is the minimal upper bound (under lexicographical ordering) of all ByteStrings that are DNS names (see 2.3.4. of RFC 1035) which is itself not a DNS name. SetElemID will identify a subset of all SetValidators on the blockchain to distinguish the SetValidators relevant to the protocol as opposed to random SetValidator addresses adversaries may have paid to.\nSetElemID will mint in two cases. The first case is the trivial initialization case – it mints only if all of the following are satisfied.\nProtocol NFT has minted.\nThere is a unique SetDatum initialized as above at SetValidator in the outputs.\nThere is no SetValidators in the inputs\nNo ElementID has minted.\nThe other case is more tricky.\nLet\nDeNSKey N C = densKey designate a new Name/Class pair for which we would like to mint an ElementID NFT SD(k,nxt)designate a SetDatum such that key = k, next = nxt INPUTS:\nA UTxO (locked at SetValidator with a SetElemID token) SD(k,nxt) where k \u003c densKey \u003c nxt OUTPUTS:\nA UTxO SD(k, densKey) (paid to the Set Validator) with a SetElemID token. A UTxO SD(densKey, nxt) (paid to the Set Validator) with a SetElemID token. MINTS:\nOne SetElemID NFT One ElementID NFT with token name blake2b_256(serialiseData(densKey)) REDEEMER:\ndata SetInsert = SetInsert { densKey :: DeNSKey } CHECKS:\nThe transaction corresponds to the above schema exactly. DISCUSSION:\nBecause the set is initialized with a lower bound and upper bound, inserting an arbitrary name n always amounts to inserting n after some known name m where m \u003c n and before some known name o s.t. n \u003c o. EXTENSIONS:\nSince the SetElemID token name isn’t used, it should be the empty string to save bytes.\nIt is possible to introduce a hierarchical ownership of names (e.g. DeNSKey 1 \"google.com.\" may be purchased only if the owner of DeNSKey 1 \"com.\" approves such a sale). We only describe the inductive case, and leave the base case up to implementations where the owner of the empty domain (for each class) would be coded directly in the smart contract. First, we will assume that a function parse :: ByteString -\u003e [ByteString] exists which maps names like \"google.com\" to [\"google\", \"com\"] i.e., parse decomposes a name into its labels, and if parse n1 is a suffix of parse n2, then we say that n2 is a subdomain of n1 (see 2.3.1). We will also assume there exists a function unparse :: [ByteString] -\u003e ByteString that is the inverse of parse. The key idea is that a subdomain must verify that the domain immediately “above” has approved purchasing the subdomain’s name.\nWe modify the datum and redeemer as follows.\ndata SetDatum = SetDatum { key :: DeNSKey , next :: DeNSKey + , ownerApproval :: CurrencySymbol + -- ^ A token which must mint in order for a subdomain to be bought } data SetInsert = SetInsert { densKey :: DeNSKey + , ownerApproval :: CurrencySymbol } Let SD(k,nxt,o) denote a SetDatum with key = k, next = nxt, ownerApproval = o.\nNow, the transaction where SetElemID mints must conform to the following schema when given redeemer SetInsert{densKey, ownerApproval} where densKey = DeNSKey N C and n:ns = parse N.\nINPUTS:\nA UTxO (locked at SetValidator with a SetElemID token) SD(k,nxt,o) where k \u003c densKey \u003c nxt REFERENCE INPUTS:\nA UTxO (locked at SetValidator with a SetElemID token) SD(unparse ns, _, domainOwner) OUTPUTS:\nA UTxO SD(k,densKey,o) (paid to the SetValidator) with a SetElemID token A UTxO SD(densKey,nxt,ownerApproval) (paid to the SetValidator) with a SetElemID token MINTS:\nOne SetElemID NFT with token name. One ElementID NFT with token name blake2b_256(serialiseData(densKey)) At least one token from the domainOwner from the reference input is minted. Note how the ownerApproval is an extra check to verify that this subdomain purchase has been approved by the domain immediately “above” it. A simple ownerApproval script could verify if some public key has signed the transaction, or some token (controlled by the owner) has been burned.\nOne may consider to not allow DeNSKeys with empty strings to be inserted.\nSetValidator validator SetValidator is the validator address which holds the elements in the logical database. It simply validates only if SetElemID mints i.e., it forwards all verifications to SetElemID.\nDISCUSSION: Since SetValidator forwards everything to SetElemID, this makes the potential for upgrading to a new SetElemID convenient as swapping to a new SetElemID' would still keep existing SetElemID already at SetValidator meaning there would be no need for a large migration of tokens.\nElementID Minting Policy The ElementID minting policy is an NFT which serves as an access control identifier in order to gate access to specific records in the virtual DeNS database.\nCHECKS::\nSetElemID mints in the same transaction DISCUSSION:\nThis forwards all verifications to SetElemID whose minting is unique w.r.t to the element inserted in the set, and ensures that this ElementID’s token name contains sufficient information to identify it with the inserted element.\nRecords Validator The records validator serves as an access control list for the virtual DeNS database. When the offchain code reconstructs the database from Cardano keys and Arweave values, it treats the records locked at the Records validator identified with a ElementID token as the source of authority. That is: Only records locked at the records validator are used to construct the database used in a DeNS resolver.\nPARAMETERS:\nThe Protocol NFT DATUM:\nThe Records Validator datum functions as the key in our virtual database. To update or create a record, a DeNS user simply adjusts the reference for the class and name that they own. To delete a record, the user submits a transaction with an output datum where the reference field is Nothing.\ndata RecordDatum = RecordDatum { class :: Word16 , name :: ByteString , reference :: Maybe ByteString -- ^ an Arweave address , owner :: PubKeyHash } The offchain code that constructs the DeNS database will always treat the most recent record associated with a given name as authoritative, and consequently we do not need to distinguish between record creation and record deletion. (Unlike the SetValidator, we do not need a simulated Map or Set).\nINPUTS:\nA UTxO containing a NFT where the AssetClass consists of a CurrencySymbol == the hash of the ElementID MintingPolicy and where the token name is (or should be) == the blake2b hash calculated from blake2b_256 (serialiseData(redeemer.class , redeemer.name)) OUTPUTS:\nA UTxO, paid to the Records Validator, which contains the RecordDatum passed by the user MINTS: N/A\nCHECKS:\nThe transaction is signed by owner DISCUSSION: Since the owner owns the token, this validator gives them “free reign” to update it as they please. In practise, to not confuse offchain code and devalue one’s own Records (by e.g. giving it to someone else for free), one would most likely want to check the following conditions as well\nThe NFT in the inputs contains a token that satisfies the constraints outlined above in the section The output contains a single UTxO with an inline RecordDatum datum which is equal to the input passed in by the user This output UTxO is paid to the validator Architecture—Arweave (Technical) (WIP) Why not Cardano? The current size of a file containing the totality of domains in internet is estimated in 10 GB.\nCardano maximum size for a transaction is 16 KB.\nThis means that we have to perform 655_360 transactions in the optimistic case. The time and cost of this amount of transactions is prohibitive, specifically for initialization. We need a secondary way to store data.\nWhy Arweave? It seems that the maximum amount of data we can upload paying the minimum amount possible in Arweave is:\nhttps://arweave.net/price/256000 212017846 Here the 256000 are the bytes for upload and 212017846 is the response in Wilson.\nA Wilson is related to AR (the Arweave currency) as:\nAR = 1e12 Wilson At today the price of an AR is around 9.5 USD, this means that the minimum cost of a transaction is : 0.002014169537 USD. And the maximum size of a transaction with such a price is above 250 KB.\nAdditionally, some gateways allow the upload of certain amount of bytes for free. For example, Irys allow us to upload 200 KB for free in Node2.\nThose are the reasons we choose to store every set of records in a particular zone file as a single transaction.\nInitial Upload Initially, we will assume we have the following zone files.\nZoneCOM.txt ZoneNET.txt . . . ZoneSome.txt We will transform them, striping redundant data and complementing with other files (to avoid breaking the TOS). Eventually we will reach a new state in which we will have small chunks of data of size ORIGINAL_CHUNK_SIZE (to be defined).\nThen using the services of a bundler we will upload the chunks in bulk to Arweave.\nArweave has a limit of transactions per block, but they allow the use of bundle transactions that allows the inclusion of up to 2^256 transactions in every bundle. Although the cost of upload can increase (to be investigated), this allows the resolution of a query by only downloading a single chunk instead of waiting for the download of an entire zone file. Additionally, we believe that the increase cost won’t be more than $100 USD, and we expect it to be much less (to be investigated).\nThe process of bundling will assign a unique transaction Id to the uploaded chunk This means that at this point the reference inside a DeNSValue is the assigned Id of the chunk.\nThis means that when someone tries to solve the ip of a domain, they need to find the right domain inside the original chunk.\nUpdate of a set of records and upload of new records After the initial upload, every owner of a domain is responsible for the update of their own records. With the use of a bundler, we can recommend them to upload a single set of records in a single transaction. But they may choose not to bundle and just upload a single transaction mixing records for other domains that they own. In such cases the local dns would only update the local records corresponding to the domain that is being updated in Cardano. This means that different domains registered in Cardano, can point to the same chunk of records.\nThis model means that the initial actor/maintainer of the network would be able to do updates in bulk with low cost and to discharge the update responsibility on a new owner in the future with ease.\nDomain Solving We have two approaches here.\nThe first one is:\nAsk the Indexer to immediately retrieve the associated Cardano transaction and then the Arweave transaction data. The second one:\nWait for the Indexer to update the Cardano and Arweave sides. To improve the last one, we can improve the priority of the information related to the domain requested.\nIn both cases the idea is to let the Cardano Indexer guide the acquisition of data in the Arweave side.\nThe full process will be:\nUser request domain D to be solved.\nCardano indexer looks for the registry of D.\nWe look for the records for D in the DB.\nWe compare the address in Cardano with the one in the DB if we find D in the DB. If is the same we return it. Otherwise, we begin the next step.\nWe check if we already have the chunk of data stored (we could have a cache of chunks). If we haven’t, we retrieve it from Arweave.\nWe look for the IP of D in the chunk, then :\nReturn the response Update the records on the DB for D Update the cache (if any) of chunks Architecture - Offchain (Technical) (WIP) The offchain infrastructure needs to provide the following services.\nEfficient UTxO queries. Of course, we must efficiently provide UTxOs for the onchain code to build transactions. In particular, some of the special needs of the onchain protocol includes:\nAn efficient mapping from CurrencySymbols/TokenNames to the UTxOs which the token resides at.\nAn efficient mapping from a DeNSKey, say k, to the UTxO in the set with the largest DeNSKey, say lb, s.t. lb \u003c k.\nProvide DNS records to query. This is straightforward – we obviously need to a method to provide DNS records compatible with existing DNS systems.\nEfficient UTxO queries Due to the peculiar needs of the onchain protocol, we will most likely need to adapt an existing chain indexer. Off the shelf solutions like Kupo (which is used internally by CTL) unfortunately supports querying UTxOs via “patterns” which in particular do not satisfy the requirement of efficiently mapping DeNSKeys to a particular UTxO in the sense mentioned above.\nAs such, we must maintain our own index to query UTxOs by e.g. maintaining an SQL database such as PostgreSQL (where note that most relational databases by construction can efficiently query achieve our desired DeNSKey query) which listens for “events” on the Cardano blockchain and updates its tables appropriately.\nOf course, we can write our own chain indexer, but it’s probably better to build off existing work such as:\nAdapting the more chain flexible indexers such as oura which filters events on the blockchain according to patterns and outputs the values to a “sink” which updates our own database. Note that we could also use marconi, but it appears to be under heavy development.\nInteracting with ogmios which provides a convenient websockets to interact with the blockchain node, and we could update our database based on the information obtained by the websockets.\nProviding DNS records We will piggyback off of existing DNS systems. This has the benefit of allowing ease of integration to existing DNS systems. We considered the following two existing DNS systems.\nBIND 9 is the first, oldest, and most commonly deployed solution. This has the immediate benefit that network engineers will already be familiar with its deployment to ease adoption of DeNS. This is an all-in-one solution which combines both the recursive resolver, and the authoritative server. Unfortunately, in DeNS, since the blockchain is the single source of truth of ownership for the RRs, there is no need to use the recursive resolver part. It is possible to disable the recursive resolver in BIND 9, but we opted with the more modular PowerDNS solution described below.\nPowerDNS consists of two parts: the authoritative server, and the recursor. The authoritative server answers questions about the domains it knows about (from its database), and importantly will not go out on the net to resolve queries about other domains. On the other hand, the recursor has no knowledge of domains itself, but will always consult other authoritative servers to answer questions given to it. Indeed, DeNS would like to integrate with only the authoritative server part of PowerDNS (ignoring the recursor), where DeNS will fill up the authoritative server’s database with its own DNS records.\nOf the two existing solutions, we believe that PowerDNS’s modularity of splitting the authoritative server and the recursor into separate entities makes it a better fit to integrate into DeNS since DeNS only needs the authoritative server functionality.\nPowerDNS requires some basic setup in order to talk to a backend database. In particular, it supports a PostgreSQL database backend. Its operation falls under the generic SQL backend category for which users can interact with it via the application pdnsutil or the REST-API. We will interact with the authoritative server via the REST-API which in particular has endpoints to manipulate zones to add RRsets – details are in the documentation here.\nFinally, the only question that remains is how updates from the blockchain should propagate to the authoritative server. We propose to piggyback back on top of the chain indexer from the previous section where we listen for the event of set changes, and on the occurrence of such event, we update the DNS records.\n","categories":"","description":"","excerpt":"Requirements (Conceptual) The DeNS protocol must support a small list …","ref":"/DeNS/docs/architecture/architecture/","tags":"","title":"Technical Specification"},{"body":" DeNS Query provides an HTTP interface for accessing the UTxOs stored in the database.\nAuthentication Some endpoints provided by DeNS Query are exposed internal functionalities to and are made available to facilitate testing and development.\nImportant To prevent malicious interactions/modifications of DeNS Query’s database, it is therefore expected that these endpoints must NOT be exposed publicly (i.e., not accessible to end-users). For this to be effective, a HTTPS reverse proxy may be used to:\nensure that proper encryption is enforced;\nguarantee host authentication; and\nmake sure that only user-specific endpoints are exposed for the public.\nBelow is a list of these internal endpoints that should not be exposed in the public API:\nPOST Set Protocol NFT\nHTTP Endpoints POST Query Set Insertion UTxO Method POST\nURL /api/query-set-insertion-utxo\nReturns the UTxO to spend in order to purchase the given domain from the smart contracts.\nExample request { \"name\": \"7461796C6F7273776966742E636F6D\" (1) } Hex encoded domain name one wishes to purchase\nExample response { \"name\": \"Ok\", \"fields\": [ { \"name\": \"676F6F676C652E636F6D\", (1) \"pointer\": (2) { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" }, \"txOutRef\": (3) { \"txOutRef\": (4) \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"txOutRefIx\": 69 (5) } } ] } Hex encoded largest purchased domain name which is lexicograpically strictly less than the provided domain name.\nAsset class which identifies the UTxOs of RRs\nTransaction output that this information resides at\nHex encoded transaction hash\nInteger index\nErrors Code\nMessage\nDescription\n400\nDomain name already exists error response\nThrown if the domain name to purchase has already been purchased\n500\nNo set elements found\nThrown if there are no UTxOs to spend in the set (most likely a misconfigured protocol)\nDomain name already exists error response TODO(jaredponn): write me No set elements found TODO(jaredponn): write me POST Protocol UTxO Method POST\nURL /api/query-protocol-utxo\nReturns the UTxO which holds the Protocol type i.e., trusted information of the DeNS protocol.\nExample request { } Example response { \"name\": \"Ok\", \"fields\": [ { \"txOutRef\": (1) { \"txOutRef\": (2) \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"txOutRefIx\": 69 (3) }, \"protocol\": (4) { \"elementIdMintingPolicy\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"setElemMintingPolicy\" : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"setValidator\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"recordsValidator\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" } } ] } Transaction output that this information resides at\nHex encoded transaction hash\nInteger index\nJSON object of hex encoded script hashes (28 bytes)\nErrors Code\nMessage\nDescription\n500\nNo protocol utxo found\nThrown if there is no UTxO for the protocol\nNo protocol utxo found TODO(jaredponn): write me POST Set Protocol NFT Method POST\nURL /api/set-protocol-nft\nSets the protocol NFT to the provided protocol NFT returning the new protocol NFT that DeNS Query now follows. In other words, recalling that all instances of the DeNS protocol are uniquely identified by a protocol NFT, setting the protocol NFT to a new protocol NFT therefore changes the instance of the DeNS protocol that this DeNS Query server follows.\nExample request { \"protocolNft\": { \"currency_symbol\": \" 0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } Example response { \"name\": \"Ok\", \"fields\": [ { \"protocolNft\": { \"currency_symbol\": \" 0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } ] } LambdaBuffers All datum described in the requests and responses in HTTP Endpoints have an associated LambdaBuffers type with generated JSON parsers. Refer to the .lbf schema file for more details.\n","categories":"","description":"","excerpt":" DeNS Query provides an HTTP interface for accessing the UTxOs stored …","ref":"/DeNS/docs/dens-query/http_api/","tags":"","title":"HTTP API"},{"body":" Note Readers may skip this section. DeNS query uses PostgreSQL with many PostgreSQL specific extensions. In particular, the PostgreSQL specific extensions were used to respond to blockchain rollbacks where the blockchain will rollback to a particular block requiring the protocol to undo all the changes from the present to the block to rollback to.\nDatabase schema source code -- = Overview -- For each \"kind of UTxO\" for the dens protocol, we create a table for it e.g. -- we have tables -- - `+dens_set_utxos+` -- - `+dens_elem_ids+` -- - `+dens_protocol_utxos+` -- We call such a table a _dens table_. -- Each of these dens tables has a foreign key to `+tx_out_refs+` s.t. when a -- UTxO gets spent, we may simply delete the corresponding transaction output -- `+tx_out_refs+` where the deletion will cascade down to the dens table. -- Note that the `+tx_out_refs+` has foreign keys to the `+blocks+` table. -- -- To handle rollbacks (recall a rollback is when the blockchain \"goes back\" to -- a previous block state), we have the `+undo_log+` table which associates -- blocks with the inverse operation of the SQL statements that changed dens -- tables (or the `+tx_out_refs+`/`+blocks+` table). -- Thus, rolling back amounts to executing each of the SQL statements stored in -- `+undo_log+` until we reach the block that we must roll back to. -- Finally, to maintain the `+undo_log+`, we essentially create a \"higher order -- function\" which creates a trigger for each of the dens tables (and the -- `+tx_out_refs+`/`+blocks+` table) which records the inverse SQL operation in -- the `+undo_log+` table. -- One wrinkle with the triggers is that cascaded SQL operations don't execute -- the triggers in the \"right order\" e.g. if we have table A and table B where -- B has a foreign key to A, and we delete something in A, the trigger for A -- will run, then the trigger for B will run -- so undoing will temporarily -- violate the foreign key constraint. Hence, why we always have `+DEFERRABLE+` -- set for foreign keys. -- -- Finally, this schema assumes that we are only following a single DeNS -- protocol. Thus, it assumes that there is a unique protocol NFT we are -- interested in following -- see the table `+dens_protocol_nft+` for details. -- -- -- = References -- -- * [#ogmios] https://ogmios.dev/api/ ----------------------------------------------------------------------------- -- = Types ----------------------------------------------------------------------------- CREATE TYPE asset_class_type AS ( currency_symbol bytea, token_name bytea ); CREATE DOMAIN asset_class AS asset_class_type CONSTRAINT currency_symbol_not_null CHECK (((VALUE).currency_symbol IS NOT NULL)) CONSTRAINT token_name_not_null CHECK (((VALUE).token_name IS NOT NULL)) -- https://github.com/IntersectMBO/plutus/blob/1.16.0.0/plutus-ledger-api/src/PlutusLedgerApi/V1/Value.hs#L75-L92 CONSTRAINT currency_symbol_length CHECK ((octet_length((VALUE).currency_symbol) = 0) OR (octet_length((VALUE).currency_symbol) = 28)) -- https://github.com/IntersectMBO/plutus/blob/1.16.0.0/plutus-ledger-api/src/PlutusLedgerApi/V1/Value.hs#L99-L112 CONSTRAINT token_name_length CHECK (octet_length((VALUE).token_name) \u003c= 32); ----------------------------------------------------------------------------- -- = Tables for general information about the blockchain ----------------------------------------------------------------------------- -- All blocks in the blockchain. CREATE TABLE IF NOT EXISTS blocks ( block_slot bigint NOT NULL, block_id bytea NOT NULL, PRIMARY KEY (block_id, block_slot) ); -- Transaction outputs relevant to the dens tables CREATE TABLE IF NOT EXISTS tx_out_refs ( tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, block_slot bigint NOT NULL, block_id bytea NOT NULL, FOREIGN KEY (block_id, block_slot) REFERENCES blocks (block_id, block_slot) ON DELETE CASCADE DEFERRABLE, -- https://github.com/IntersectMBO/plutus/blob/1.16.0.0/plutus-ledger-api/src/PlutusLedgerApi/V1/Tx.hs#L51-L65 CONSTRAINT tx_id_length_is_32 CHECK (octet_length(tx_out_ref_id) = 32), PRIMARY KEY (tx_out_ref_id, tx_out_ref_idx) ); ----------------------------------------------------------------------------- -- = Tables for the protocol ----------------------------------------------------------------------------- ----------------------------------------------------------------------------- -- == Table for the Linked list for associating domain names to RRs ----------------------------------------------------------------------------- -- Linked list set data structure CREATE TABLE IF NOT EXISTS dens_set_utxos ( -- Unique identifier for the names id bigserial UNIQUE, -- name for the DNS record that is owned name bytea UNIQUE, -- Token which associates this `+name+` with a validator address which -- actually holds (a reference) to the RRs. pointer asset_class NOT NULL, tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, PRIMARY KEY (tx_out_ref_id, tx_out_ref_idx), FOREIGN KEY (tx_out_ref_id, tx_out_ref_idx) REFERENCES tx_out_refs (tx_out_ref_id, tx_out_ref_idx) ON DELETE CASCADE DEFERRABLE ); -- Index s.t. one can efficiently query if change has happened in the -- dens_set_utxos CREATE INDEX IF NOT EXISTS dens_set_utxos_asset_class ON dens_set_utxos (pointer); -- Index s.t. one can efficiently query which UTxO to spend CREATE INDEX IF NOT EXISTS dens_set_utxos_name ON dens_set_utxos (name); ----------------------------------------------------------------------------- -- == Table for representing the UTxOs which contain RRs ----------------------------------------------------------------------------- -- `+TxOutRef+`s which contain the dens_set_utxos(pointer) -- i.e., these are the UTxOs which identify the transactions which contain -- transaction outputs that contain RRs as datum. CREATE TABLE IF NOT EXISTS dens_elem_ids ( id bigserial UNIQUE, tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, asset_class asset_class NOT NULL, PRIMARY KEY(id), UNIQUE (asset_class), UNIQUE (tx_out_ref_id, tx_out_ref_idx, asset_class), FOREIGN KEY (tx_out_ref_id, tx_out_ref_idx) REFERENCES tx_out_refs (tx_out_ref_id, tx_out_ref_idx) ON DELETE CASCADE DEFERRABLE ); CREATE INDEX IF NOT EXISTS dens_elem_ids_asset_classes ON dens_elem_ids(asset_class); -- The list of RRs at `+DensValidator+`s addresses i.e., this forms a -- . M:1 relationship of `+dens_rrs+` to `+dens_elem_ids+` -- -- NOTE:(jaredponn): so unlike the rest of the tables, the UTxOs we are -- interested in are controlled by how an asset class at `+dens_elem_ids+` -- is traded i.e., -- -- . If the asset class at `+dens_elem_ids+` is traded (i.e., if this -- UTxO is consumed), then the RRs are deleted -- -- Contrast this to how all other tables have FKs to the `+tx_out_refs+` table -- -- NOTE(jaredponn): this loosely follows the records table in -- \u003chttps://github.com/PowerDNS/pdns/blob/0b6eb67e14ce894e8286c0993e393b1191411c96/modules/gpgsqlbackend/schema.pgsql.sql\u003e -- NOTE(jaredponn): the only DNS backend we support is PowerDNS. The following -- are useful docs: -- . \u003chttps://github.com/PowerDNS/pdns/blob/0b6eb67e14ce894e8286c0993e393b1191411c96/modules/gpgsqlbackend/schema.pgsql.sql\u003e -- for the schema -- . \u003chttps://github.com/PowerDNS/pdns/blob/0b6eb67e14ce894e8286c0993e393b1191411c96/modules/gpgsqlbackend/gpgsqlbackend.cc\u003e -- . In the future, it'll probably be a reasonable idea to write up our own Cardano backend. -- See over here: \u003chttps://doc.powerdns.com/authoritative/appendices/backend-writers-guide.html\u003e for details CREATE TABLE IF NOT EXISTS dens_rrs ( id bigserial, -- The type of the RR e.g. `+A+`, `+AAAA+`, etc. type varchar(10) NOT NULL, ttl int NOT NULL, content varchar(65535) NOT NULL, dens_elem_id bigserial, PRIMARY KEY(id), FOREIGN KEY (dens_elem_id) REFERENCES dens_elem_ids(id) ON DELETE CASCADE DEFERRABLE ); ----------------------------------------------------------------------------- -- == Table for the protocol UTxO ----------------------------------------------------------------------------- CREATE TABLE IF NOT EXISTS dens_protocol_utxos ( element_id_minting_policy bytea NOT NULL, set_elem_minting_policy bytea NOT NULL, set_validator bytea NOT NULL, records_validator bytea NOT NULL, tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, PRIMARY KEY (tx_out_ref_id, tx_out_ref_idx), FOREIGN KEY (tx_out_ref_id, tx_out_ref_idx) REFERENCES tx_out_refs (tx_out_ref_id, tx_out_ref_idx) ON DELETE CASCADE DEFERRABLE ); ----------------------------------------------------------------------------- -- == Table for the protocol NFT ----------------------------------------------------------------------------- -- Note that we assume that we are only following a single instance of the DeNS -- protocol in this schema, so really _all_ DeNS tables depend on this table; -- and hence have a foreign key to this table. -- But, to simplify the schema, we only allow at most one dens_protocol_nft to -- exist, and hence we don't write this foreign key dependency explicitly in -- the tables. -- See `+dens_set_protocol_nft+` for details. CREATE TABLE IF NOT EXISTS dens_protocol_nft( at_most_one boolean PRIMARY KEY DEFAULT TRUE, asset_class asset_class NOT NULL, CONSTRAINT at_most_one CHECK (at_most_one) ); ----------------------------------------------------------------------------- -- = Tables for the undo log ----------------------------------------------------------------------------- -- Associates a block (the block id and block slot) with an SQL statement to -- undo something. -- TODO(jaredponn): we can play around with the length of undo_log and make it -- based on the maximum length of the rollback to save some memory. -- See https://cips.cardano.org/cip/CIP-9/ for details. CREATE TABLE IF NOT EXISTS undo_log ( seq bigserial, block_slot bigint NOT NULL, block_id bytea NOT NULL, undo_statement text NOT NULL, FOREIGN KEY (block_id, block_slot) REFERENCES blocks (block_id, block_slot) ON DELETE CASCADE DEFERRABLE, PRIMARY KEY (seq) ); CREATE INDEX IF NOT EXISTS undo_log_block_id_and_block_slot ON undo_log (block_slot, block_id); -- Gets the most recent block CREATE OR REPLACE FUNCTION get_most_recent_block() RETURNS blocks AS $body$ DECLARE most_recent_block blocks; BEGIN SELECT blocks.block_slot, blocks.block_id INTO most_recent_block FROM blocks WHERE blocks.block_slot = (SELECT max(block_slot) FROM blocks); RETURN most_recent_block; END $body$ LANGUAGE plpgsql; -- Given a `+table_name+`, returns `+\u003ctable_name\u003e_undo_insert+`. This exists to -- ensure that we have a consistent way of generating the trigger / function -- name associated with a table. CREATE OR REPLACE FUNCTION create_undo_insert_name(table_name text) RETURNS text AS $body$ BEGIN RETURN table_name || '_undo_insert'; END $body$ LANGUAGE plpgsql; -- Creates a function and trigger with the name `+table_name_undo_insert+` -- which on insertion to `+table_name+`, assuming that `+undo_log.freeze_log+` -- is not true, appends an SQL statement of the form -- --- -- format -- ( $$ DELETE FROM table_name WHERE primary_key1 = %L AND ... primary_keyN = %L $$ -- , NEW.primary_key1 -- , ... -- , NEW.primary_keyN -- ) -- --- -- to `+undo_log+` associated with the most recently added block (if it exists, -- otherwise we do nothing). CREATE OR REPLACE FUNCTION create_table_undo_insert(table_name text) RETURNS void AS $body$ DECLARE name text := create_undo_insert_name(table_name); sql_is_primary_keys text; sql_new_primary_keys text; BEGIN CREATE TEMP TABLE table_primary_keys( primary_key text ) ON COMMIT DROP; -- See \u003chttps://wiki.postgresql.org/wiki/Retrieve_primary_key_columns\u003e -- for details INSERT INTO table_primary_keys SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = CAST (table_name AS regclass) AND i.indisprimary; -- Create a string of the form -- --- -- primary_key1 = %L AND primary_key2 = %L ... AND primary_keyN = %L -- --- SELECT string_agg(format('%I = %%L', primary_key), ' AND ' ORDER BY primary_key ASC) INTO STRICT sql_is_primary_keys FROM table_primary_keys; -- Create a string of the form -- --- -- NEW.primary_key1, NEW.primary_key2, ..., NEW.primary_keyN -- --- SELECT string_agg(format('NEW.%I', primary_key), ',' ORDER BY primary_key ASC) INTO STRICT sql_new_primary_keys FROM table_primary_keys; EXECUTE format( $undo_function$ CREATE OR REPLACE FUNCTION %I() RETURNS trigger AS $$ DECLARE most_recent_block record := get_most_recent_block(); BEGIN IF current_setting('undo_log.freeze_log', TRUE) = CAST(TRUE AS TEXT) THEN RETURN NEW; END IF; IF most_recent_block IS NOT NULL THEN -- if there is no block, then we can't associate the undo log with anything INSERT INTO undo_log (seq, block_slot, block_id, undo_statement) VALUES (DEFAULT, most_recent_block.block_slot, most_recent_block.block_id, format(%L, %s)); END IF; RETURN NEW; END $$ LANGUAGE plpgsql; $undo_function$, name, format('DELETE FROM %I WHERE %s', table_name, sql_is_primary_keys), sql_new_primary_keys ); EXECUTE format( $undo_trigger$ CREATE OR REPLACE TRIGGER %I AFTER INSERT ON %I FOR EACH ROW EXECUTE FUNCTION %I(); $undo_trigger$, name, table_name, name ); DROP TABLE IF EXISTS table_primary_keys; END $body$ LANGUAGE plpgsql; -- Given a `+table_name+`, returns `+\u003ctable_name\u003e_undo_delete+`. This exists to -- ensure that we have a consistent way of generating the trigger / function -- name associated with a table. CREATE OR REPLACE FUNCTION create_undo_delete_name(table_name text) RETURNS text AS $body$ BEGIN RETURN table_name || '_undo_delete'; END $body$ LANGUAGE plpgsql; -- Creates a function and trigger with the name `+table_name_undo_delete+` -- which on deletion to `+table_name+`, assuming that `+undo_log.freeze_log+` -- is not true, append an SQL statement of the form -- --- -- format -- ( $$ INSERT INTO table_name VALUES ((CAST (%L AS table_name)).*) $$ -- , NEW -- ) -- --- -- to `+undo_log+` associated with the most recently added block (if it exists, -- otherwise we do nothing). CREATE OR REPLACE FUNCTION create_table_undo_delete(table_name text) RETURNS void AS $body$ DECLARE name text := create_undo_delete_name(table_name); BEGIN EXECUTE format( $undo_function$ CREATE OR REPLACE FUNCTION %I() RETURNS trigger AS $$ DECLARE most_recent_block record := get_most_recent_block(); BEGIN IF current_setting('undo_log.freeze_log', TRUE) = CAST(TRUE as TEXT) THEN RETURN OLD; END IF; IF most_recent_block IS NOT NULL THEN -- if there is no block, then we can't associate the undo log with anything INSERT INTO undo_log (seq, block_slot, block_id, undo_statement) VALUES (DEFAULT, most_recent_block.block_slot, most_recent_block.block_id, format(%L, OLD)); END IF; RETURN OLD; END $$ LANGUAGE plpgsql; $undo_function$, name, format('INSERT INTO %I VALUES ((CAST (%%L AS %I)).*)', table_name, table_name) ); EXECUTE format( $undo_trigger$ CREATE OR REPLACE TRIGGER %I AFTER DELETE ON %I FOR EACH ROW EXECUTE FUNCTION %I(); $undo_trigger$, name, table_name, name ); END $body$ LANGUAGE plpgsql; -- Given a `+table_name+`, returns `+\u003ctable_name\u003e_undo_update+`. This exists to -- ensure that we have a consistent way of generating the trigger / function -- name associated with a table. CREATE OR REPLACE FUNCTION create_undo_update_name(table_name text) RETURNS text AS $body$ BEGIN RETURN table_name || '_undo_update'; END $body$ LANGUAGE plpgsql; -- Creates a function and trigger with the name `+table_name_undo_update+` -- which on update to `+table_name+`, assuming that `+undo_log.freeze_log+` -- is not true, appends an SQL statement of the form -- --- -- format -- ( $$ UPDATE table_name SET column_name1 = %L, ..., column_nameN = %L WHERE primary_key1 = %L AND ... AND primary_keyM = %L; -- , OLD.column_name1 -- , ... -- , OLD.column_nameN -- , NEW.primary_key1 -- , ... -- , NEW.primary_keyM -- ) -- --- -- to `+undo_log+` associated with the most recently added block (if it exists, -- otherwise we do nothing). CREATE OR REPLACE FUNCTION create_table_undo_update(table_name text) RETURNS void AS $body$ DECLARE name text := create_undo_update_name(table_name); sql_is_primary_keys text; sql_new_primary_keys text; sql_set_columns text; sql_old_columns text; BEGIN -- = SQL strings relating to the primary keys CREATE TEMP TABLE table_primary_keys( primary_key text ) ON COMMIT DROP; -- See \u003chttps://wiki.postgresql.org/wiki/Retrieve_primary_key_columns\u003e -- for details INSERT INTO table_primary_keys SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = CAST (table_name AS regclass) AND i.indisprimary; -- Create a string of the form -- --- -- primary_key1 = %L AND primary_key2 = %L ... AND primary_keyN = %L -- --- SELECT string_agg(format('%I = %%L', primary_key), ' AND ' ORDER BY primary_key ASC) INTO STRICT sql_is_primary_keys FROM table_primary_keys; -- Create a string of the form -- --- -- NEW.primary_key1, NEW.primary_key2, ..., NEW.primary_keyN -- --- SELECT string_agg(format('NEW.%I', primary_key), ',' ORDER BY primary_key ASC) INTO STRICT sql_new_primary_keys FROM table_primary_keys; -- = SQL strings relating to all columns CREATE TEMP TABLE table_column_names( column_name text ) ON COMMIT DROP; INSERT INTO table_column_names SELECT i.attname FROM pg_attribute i WHERE i.attrelid = CAST (table_name AS regclass) AND i.attnum \u003e 0 AND NOT i.attisdropped; -- Create a string of the form -- --- -- column_name1 = %L, column_name2 = %L, ..., column_nameN = %L -- --- SELECT string_agg(format('%I = %%L', column_name), ',' ORDER BY column_name ASC) INTO STRICT sql_set_columns FROM table_column_names; -- Create a string of the form -- --- -- OLD.column_name1, column_name2, ..., OLD.column_nameN -- --- SELECT string_agg(format('OLD.%I', column_name), ',' ORDER BY column_name ASC) INTO STRICT sql_old_columns FROM table_column_names; EXECUTE format( $undo_function$ CREATE OR REPLACE FUNCTION %I() RETURNS trigger AS $$ DECLARE most_recent_block record := get_most_recent_block(); BEGIN IF current_setting('undo_log.freeze_log', TRUE) = CAST(TRUE AS TEXT) THEN RETURN NEW; END IF; IF most_recent_block IS NOT NULL THEN -- if there is no block, then we can't associate the undo log with anything INSERT INTO undo_log (seq, block_slot, block_id, undo_statement) VALUES (DEFAULT, most_recent_block.block_slot, most_recent_block.block_id, format(%L, %s, %s)); END IF; RETURN NEW; END $$ LANGUAGE plpgsql; $undo_function$, name, format('UPDATE %I SET %s WHERE %s', table_name, sql_set_columns, sql_is_primary_keys), sql_old_columns, sql_new_primary_keys ); EXECUTE format( $undo_trigger$ CREATE OR REPLACE TRIGGER %I AFTER UPDATE ON %I FOR EACH ROW EXECUTE FUNCTION %I(); $undo_trigger$, name, table_name, name ); DROP TABLE IF EXISTS table_primary_keys; DROP TABLE IF EXISTS table_column_names; END $body$ LANGUAGE plpgsql; -- Freezes the `+undo_log+` i.e., stops triggers from automatically adding -- things to the `+undo_log+` in the current transaction CREATE OR REPLACE FUNCTION freeze_undo_log() RETURNS void as $body$ BEGIN SET LOCAL undo_log.freeze_log = TRUE; END $body$ LANGUAGE plpgsql; -- Unfreezes the `+undo_log+` i.e., allows things to be added to the -- `+undo_log+` again in the current transaction CREATE OR REPLACE FUNCTION unfreeze_undo_log() RETURNS void as $body$ BEGIN SET LOCAL undo_log.freeze_log = FALSE; END $body$ LANGUAGE plpgsql; -- Roll backs the database to the given block i.e., -- Using the `+undo_log+`, execute all `+undo_statement+` _strictly after_ the -- provided block, and delete such rows from the `+undo_log+`. CREATE OR REPLACE FUNCTION undo_log_rollback_to(block_slot bigint, block_id bytea) RETURNS void AS $body$ DECLARE to_undo record; BEGIN SET CONSTRAINTS ALL DEFERRED; PERFORM freeze_undo_log(); FOR to_undo IN WITH deleted AS( DELETE FROM undo_log WHERE undo_log.block_slot \u003e undo_log_rollback_to.block_slot RETURNING * ) SELECT * FROM deleted ORDER BY seq DESC LOOP IF to_undo.undo_statement IS NOT NULL THEN EXECUTE to_undo.undo_statement; END IF; END LOOP; PERFORM unfreeze_undo_log(); END $body$ LANGUAGE plpgsql; ----------------------------------------------------------------------------- -- = Undo log triggers ----------------------------------------------------------------------------- SELECT create_table_undo_insert('blocks'); SELECT create_table_undo_delete('blocks'); SELECT create_table_undo_insert('tx_out_refs'); SELECT create_table_undo_delete('tx_out_refs'); SELECT create_table_undo_update('tx_out_refs'); SELECT create_table_undo_insert('dens_set_utxos'); SELECT create_table_undo_delete('dens_set_utxos'); SELECT create_table_undo_update('dens_set_utxos'); SELECT create_table_undo_insert('dens_elem_ids'); SELECT create_table_undo_delete('dens_elem_ids'); SELECT create_table_undo_update('dens_elem_ids'); SELECT create_table_undo_insert('dens_rrs'); SELECT create_table_undo_delete('dens_rrs'); SELECT create_table_undo_update('dens_rrs'); SELECT create_table_undo_insert('dens_protocol_utxos'); SELECT create_table_undo_delete('dens_protocol_utxos'); SELECT create_table_undo_update('dens_protocol_utxos'); ----------------------------------------------------------------------------- -- = Helper functions ----------------------------------------------------------------------------- -- If the provided asset class (currency symbol / token name) matches the -- existing asset class in the `+dens_protocol_nft+` table, do nothing. -- Otherwise, overwrite the existing `+dens_protocol_nft+` CREATE OR REPLACE FUNCTION dens_set_protocol_nft(currency_symbol bytea, token_name bytea) RETURNS dens_protocol_nft AS $body$ DECLARE old_protocol_nft dens_protocol_nft; new_protocol_nft dens_protocol_nft; BEGIN SELECT * INTO old_protocol_nft FROM dens_protocol_nft; INSERT INTO dens_protocol_nft(asset_class) VALUES(CAST(ROW(dens_set_protocol_nft.currency_symbol, dens_set_protocol_nft.token_name) AS asset_class)) ON CONFLICT (at_most_one) DO UPDATE SET asset_class = (EXCLUDED).asset_class; SELECT * INTO STRICT new_protocol_nft FROM dens_protocol_nft; IF old_protocol_nft IS NULL THEN RETURN new_protocol_nft; END IF; IF (old_protocol_nft).asset_class = (new_protocol_nft).asset_class THEN RETURN new_protocol_nft; END IF; RETURN new_protocol_nft; END $body$ LANGUAGE plpgsql; -- Resets the database if the current protocol NFT stored in the database -- differs from the provided NFT, and returns the current protocol NFT stored -- in the database CREATE OR REPLACE FUNCTION dens_sync_protocol_nft(currency_symbol bytea, token_name bytea) RETURNS dens_protocol_nft AS $body$ DECLARE current_protocol_nft dens_protocol_nft; BEGIN SELECT * INTO current_protocol_nft FROM dens_protocol_nft; IF current_protocol_nft IS NULL THEN -- Clear all tables if there is no current protocol NFT TRUNCATE blocks * RESTART IDENTITY CASCADE; RETURN ROW(true, currency_symbol,token_name); END IF; -- If the current protocol NFT matches the provided NFT, we're good, so do nothing and return IF (current_protocol_nft).asset_class = ROW(currency_symbol, token_name) THEN RETURN current_protocol_nft; END IF; TRUNCATE blocks * RESTART IDENTITY CASCADE; RETURN current_protocol_nft; END $body$ LANGUAGE plpgsql; -- Gets a collection of the most recent points suitable for resynchronizing -- with the blockchain after shutting down. -- TODO(jaredponn): there's a better way to do this e.g. use binary search to -- find the first common point. This requires a somewhat tricky interactions -- between ogmios / postgres; and it's unclear if this would actually be better -- at all. CREATE OR REPLACE FUNCTION dens_recent_points() RETURNS SETOF blocks AS $body$ BEGIN RETURN QUERY SELECT block_slot, block_id FROM blocks ORDER BY blocks.block_slot DESC LIMIT 64; END $body$ LANGUAGE plpgsql; -- Tests if the provided name is valid. See Section 3.5 of -- \u003chttps://datatracker.ietf.org/doc/html/rfc1034\u003e. -- Moreover, differing from the specification, we only allow names to be lower -- case. -- -- For compatibility with DNS backends like PowerDNS, we must ensure: -- - names are NEVER terminated with a trailing `.`, -- - with the exception of the root zone, which must have the name of `.` -- See \u003chttps://doc.powerdns.com/authoritative/backends/generic-sql.html#:~:text=The%20generic%20SQL%20backends%20(like,needed%20to%20cover%20all%20needs.\u003e CREATE OR REPLACE FUNCTION dens_is_valid_name(name bytea) RETURNS boolean AS $body$ BEGIN RETURN encode(name, 'escape') SIMILAR TO '.|(([a-z]([-a-z0-9]*[a-z0-9])?)(.([a-z]([-a-z0-9]*[a-z0-9])?))*)'; END $body$ LANGUAGE plpgsql; ","categories":"","description":"","excerpt":" Note Readers may skip this section. DeNS query uses PostgreSQL with …","ref":"/DeNS/docs/dens-query/database_schema/","tags":"","title":"Database Schema"},{"body":" This section describes the design of all components of DeNS.\n","categories":"","description":"","excerpt":" This section describes the design of all components of DeNS.\n","ref":"/DeNS/docs/architecture/","tags":"","title":"Design \u0026 Architecture"},{"body":" DeNS Query Layer Development Milestone Outputs\nA package that listens to Cardano transactions that are related to DeNS and populates a relational database. This serves as the main query layer for other applications like DNS analytics (we expect this to be particularly useful for security-related applications) but also as the database from which traditional DNS service integration can take place.\nThe package which listens to Cardano transactions that are related to DeNS and populates a relational database can be found here.\nThe documentation for this package can be found here.\nAcceptance criteria\nThe aforementioned package is able to populate a relational database of DNS records by querying/indexing testnet transactions.\nThe aforementioned package is able to do this as demonstrated in the evidence of milestone completion below.\nEvidence of milestone completion\nLinks to PRs, issues and commits in the DeNS repository where the objectives of the milestone are achieved will be made available so that the Catalyst community and public can review the code.\nThis commit contains the package for the milestone completion.\nVideo demonstration of the use of the package that shows the successful operation of the query layer will be posted on YouTube. A link will be provided to the community in the DeNS repository.\nThe video can be found here.\nNote The video demonstration of the package follows the execution of the integration testsuite which uses plutip to create a disposable private testnet for Cardano transactions. Using plutip permits the integration tests to be reproducibly executed with CI.\n","categories":"","description":"","excerpt":" DeNS Query Layer Development Milestone Outputs\nA package that listens …","ref":"/DeNS/docs/catalyst-reports/milestone-3/","tags":"","title":"Milestone 3"},{"body":" This describes the DeNS query component of DeNS. DeNS Query is an HTTP server that syncs with the Cardano blockchain (using Ogmios as an interface to the blockchain) by providing a PostgreSQL database of all UTxOs containing relevant information to the DeNS protocol.\n","categories":"","description":"","excerpt":" This describes the DeNS query component of DeNS. DeNS Query is an …","ref":"/DeNS/docs/dens-query/","tags":"","title":"DeNS Query"},{"body":" This project was graciously funded by the Cardano Treasury in Catalyst Fund 10.\nThe following sections demonstrate evidence of achievement for the project’s milestones.\n","categories":"","description":"","excerpt":" This project was graciously funded by the Cardano Treasury in …","ref":"/DeNS/docs/catalyst-reports/","tags":"","title":"Catalyst reports"},{"body":" This describes the DeNS query component of DeNS. DeNS Query is an HTTP server that syncs with the Cardano blockchain (using Ogmios as an interface to the blockchain) by providing a PostgreSQL database of all UTxOs containing relevant information to the DeNS protocol.\n","categories":"","description":"","excerpt":" This describes the DeNS query component of DeNS. DeNS Query is an …","ref":"/DeNS/docs/dens-query/readme/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/DeNS/categories/","tags":"","title":"Categories"},{"body":" DeNS: Decentralized Name System Documentation Download A decentralized name system built on the Cardano blockchain\nDeNS is a blockchain-based name resolution service that is an alternative to DNS with much stronger security, transparency, anti-censorship, and anti-centralization guarantees.\n","categories":"","description":"","excerpt":" DeNS: Decentralized Name System Documentation Download A …","ref":"/DeNS/","tags":"","title":"DeNS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/DeNS/tags/","tags":"","title":"Tags"}]