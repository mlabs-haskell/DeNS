[{"body":" This describes DeNS — a decentralized name system built on the Cardano blockchain.\n","categories":"","description":"","excerpt":" This describes DeNS — a decentralized name system built on the …","ref":"/DeNS/docs/","tags":"","title":"DeNS"},{"body":" The executable dens-pdns-backend-cli is a remote backend to PowerDNS which facilitates propagating RRs stored in DeNS Query’s database to PowerDNS so traditional DNS resolvers are able to transitvely query the blockchain for RRs.\nIn the git repository, it is provided at the flake output dens-pdns-backend, so Nix users can enter a shell with the dens-pdns-backend-cli executable with the following command.\nnix shell github:mlabs-haskell/DeNS#dens-pdns-backend When dens-pdns-backend-cli executes, it needs the following environment variables set.\nSOCKET_PATH: the path of the Unix domain socket it will run on.\nEnvironment variables to connect to a PostgreSQL database with the DeNS Query database schema as described here.\nIntegration with PowerDNS To integrate this with PowerDNS, one will most likely want a pdns.conf file as follows.\nlaunch=remote remote-connection-string=unix:path=/ipc/dens-pdns-backend/dens-pdns-backend.sock zone-cache-refresh-interval=0 ### Disable all forms of caching so it always hits the blockchain for the latest information cache-ttl=0 negquery-cache-ttl=0 query-cache-ttl=0 Indeed, the path in the remote connection should be the SOCKET_PATH environment variable that dens-pdns-backend-cli listens on. This configuration also disables all forms of caching so PowerDNS will always ask the blockchain for the latest information of RRs.\n","categories":"","description":"","excerpt":" The executable dens-pdns-backend-cli is a remote backend to PowerDNS …","ref":"/DeNS/docs/dens-pdns-backend/getting_started/","tags":"","title":"Getting Started"},{"body":" DeNS Query is implemented with the dens-query-cli executable. In the git repository, it is provided at the flake output packages.\u003csystem\u003e.dens-query-cli, so Nix users can enter a shell with the dens-query-cli executable with the following command.\nnix shell github:mlabs-haskell/DeNS#dens-query-cli When dens-query-cli is executed, it will require that the following dependencies are running:\nPostgreSQL\nOgmios\nMoreover, it will look for a configuration file (see Configuration file format) provided in the environment variable in DENS_QUERY_CONFIG for the relevant dependency connection information along DeNS specific information. Thus, executing dens-query-cli from a shell will often look as follows.\nDENS_QUERY_CONFIG=./path/to/config.json dens-query-cli Configuration file format Users can choose between making dens-query-cli serve HTTP requests on the UNIX domain (via Unix domain sockets) or the Internet domain.\ndens-query-cli serving HTTP requests on the UNIX domain Example configuration file for running dens-query-cli on the UNIX domain { \"ogmios\": (1) { \"url\": \"ws://127.0.0.1:1337\" }, \"database\": (2) { \"user\": \"dens\", \"password\": \"\", \"socket\": { \"name\": \"UnixDomain\", \"fields\": [ { \"path\": \"/var/postgres/\" } ] }, \"database\": \"dens\" }, \"server\": (3) { \"name\": \"UnixDomain\", \"fields\": [ { \"path\": \"/ipc/.s.dens-query\" } ], }, \"protocolNft\": (4) { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } The connection to Ogmios.\nThe connection to a PostgreSQL database.\nThe Unix domain socket that dens-query-cli will serve HTTP requests on.\nThe protocol’s NFT to uniquely identify the DeNS protocol used. The currency_symbol and token_name are hex encoded.\ndens-query-cli serving HTTP requests on the Internet domain Example configuration file for running dens-query-cli on the Internet domain { \"ogmios\": { \"url\": \"ws://127.0.0.1:1337\" }, \"database\": { \"database\": \"dens\", \"password\": \"\", \"socket\": { \"name\": \"UnixDomain\", \"fields\": [ { \"path\": \"/var/postgres/\" } ] }, \"user\": \"dens\" }, \"server\": (1) { \"name\": \"InternetDomain\", \"fields\": [ { \"host\": \"127.0.0.1\", \"port\": \"6969\", } ], }, \"protocolNft\": { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } The host and port that dens-query-cli will serve HTTP requests on.\n","categories":"","description":"","excerpt":" DeNS Query is implemented with the dens-query-cli executable. In the …","ref":"/DeNS/docs/dens-query/getting_started/","tags":"","title":"Getting Started"},{"body":" The executable dens-transactions-cli allows one to submit transactions relating to the DeNS protocol to the blockchain. In the git repository, it is provided at the flake output dens-transactions-cli, so Nix users can enter a shell with the dens-transactions-cli executable with the following command.\nnix shell github:mlabs-haskell/DeNS#dens-transactions-cli When dens-transactions-cli executes, most commands will need the following runtime dependencies:\nOgmios\ndens-query-cli\nTip Each subcommand (described in later sections) has a --help flag to describe its usage. ","categories":"","description":"","excerpt":" The executable dens-transactions-cli allows one to submit …","ref":"/DeNS/docs/dens-transactions/getting_started/","tags":"","title":"Getting Started"},{"body":"Requirements (Conceptual) The DeNS protocol must support a small list of essential features to deliver on the promise of a decentralized, transparent, censorship-resistant, and privacy-conscious successor to the DNS protocol. These features are:\nRecords must be stored in an immutable, permanent, and public database. Users must have the ability (at least in principle) to resolve queries locally - that is, it ought to be possible for a user to reconstruct the DeNS database solely from public information, and use that database to resolve queries without sharing those queries (or the identity of the user) with any third party Users must be provided with direct control over their records, such that they can update those records without the assent or intervention of any third party. Users must have the ability to transfer ownership of their records without the assent or intervention of any third party. It must be possible to reconstruct a database, suitable for use as the primary database mapping domain names to resources in a DNS resolver, from these public records A viable and orderly transition path from traditional DNS must exist, such that existing users of DNS can gradually migrate to the DeNS protocol Overview: A Cross-Chain Database (Conceptual) The constraints outlined in the previous section give rise to an apparent dilemma: The Web3 technologies which are most suitable for the data-storage functionality (Arweave, IPFS, other distributed storage solutions) are inadequate for implementing the transaction logic, while, conversely, the Web3 technologies most suited to implement transaction logic necessary for users to have meaningful control over their records (Cardano and other smart-contract capable blockchains) are unsuitable for storing the large (relative to typical smart contracts) amounts of data necessary for a protocol that aims to replace DNS in its entirety.\nFortunately, this dilemma only poses a problem under the assumption that the database of DeNS records must exist “in one place”. Were that the case, we would be forced to choose between two unsatisfactory and cumbersome solutions: Either we would have to implement complex smart contract logic on a platform designed primarily for data storage, or implement data storage on a platform designed for contract logic. This assumption, however, is false. If we think of a database as an abstract structure that (logically) associates values (or sets of values) with specific keys, it is clear that a logical relation can be established between keys and values located on entirely distinct Web3 technologies.\nThis insight motivates the general architecture of the DeNS (onchain) protocol: DeNS will consist in a cross-chain database, such that contract logic (creating, updating, deleting, transferring ownership of) records is performed on a smart-contract capable blockchain, while data-storage is performed on a blockchain (or similar Web3 technology) designed for efficient storage and retrieval of data. Transactions on the smart-contract blockchain do not contain records as such (“inline”), but rather contain pointers (references, addresses) to resources on the data-storage Web3 platform. When constructing the database of records to be used in a resolver, transactions on the smart-contract blockchain serve as a source of authorization - only those records which are properly referenced in a suitable transaction on the smart-contract blockchain will be retrieved from the data-store and included in the final data set.\nRoot Domain Topography (Conceptual) Before moving to a detailed discussion of the DeNS protocol architecture, it is necessary to first clarify exactly what is meant (conceptually) by “names” and “records” - and, perhaps most importantly, by “ownership” - in DeNS. To motivate this discussion, it will be helpful to look at the format of a DNS record, here represented as a Haskell data type (we ignore the inner structure of DNS names and resource data here, as these are not important at this level of discussion):\ndata DNSRecord = DNSRecord { name :: DNSName, type :: Word16, class :: Word16, ttl :: Word32, rdLength :: Word16, rData :: ResourceData } Although it is commonplace (and perfectly fine in most circumstances) to think of DNS records as representing a mapping from a human-readable name to a machine-readable IP address, this is not strictly correct. The class field in a DNS record indicates the protocol that the record is concerned with, and one must know the class in order to interpret the type field (and consequently the rData field as well). In almost every interaction with DNS, the class can be assumed to be 1, which indicates an IP (Internet Protocol) record (A,AAAA,MX, etc) - the family of records with which most developers are familiar.\nWhile this may seem like a minor technical detail, it motivates several important questions about the nature of ownership, names, and records in DeNS. Because DeNS aims to support both “traditional DNS records” (which we can now operationally define as: IP class records of types specified in the relevant DNS RFCs) and new classes of records that support a variety of Web3 naming protocols, we cannot maintain the illusion that all records are IP class records. Furthermore, if we wish to sell access rights for the records associated with a given name, we must be able to specify precisely the criteria by which a record is “associated with a given name”. That is: We must be able to tell our potential customers exactly what it is they are buying.\nWe anticipate that, in the future, DeNS will support a variety of name systems. Some of them may integrate with DeNS at a deep level, such that transactions are always processed by a DeNS contract. However, we would also like to support (name resolution for) autonomous protocols which are not managed by DeNS contracts and therefore cannot assume that a single name (i.e. the value of the name field) is owned by the same entity in each supported protocol. Consequently, in DeNS, “ownership” must mean: Delegated control over the records associated with a (Name,Class) pair, where a record R is associated with a name/class pair (N,C) iff R.name == N \u0026\u0026 R.class == C.\nSimilarly, at the highest level there are no “bare names” in DeNS. A DeNS name exists in a Name-Universe which is indicated by the associated class (or, if you prefer, by the protocol the class refers to).\nRecords in DeNS, then, are just ordinary DNS records. However, in order to maximize the number of additional protocols that DeNS support, and to reduce the burden of supporting obsolete protocols, we will consider all existing DNS record classes other than 1 (IP) to be deprecated. We will not consider ourselves obliged to support these protocols, and we reserve the right to reassign their class identifier at our discretion.\nThe considerations raised in this section also constrain the logical structure of the DeNS root domain. In particular, the DeNS root domain must be universal in a sense in which the DNS root domain is not. To elaborate: What we ordinarily refer to as the DNS root domain - the set of zone files served by DNS root servers - is really a DNS root domain. Namely, it is the root domain for the IP class. There are other root domains for non-IP classes, and (e.g.) the Chaosnet root domain and the IP root domain are utterly distinct from one another. In this sense, the existing DNS root domain is not universal.\nDeNS, by contrast, will be universal. Concretely, this implies that the records which constitute the DeNS top-level root domain will contain resources which are associated with a class, and not, as with DNS, a top-level domain. In this way, we can support a wide variety of different protocols, including protocols that serve as their own autonomous top-level domain.\nThis architecture allows us to specify more clearly the mechanics of the transition away from DNS as an authority for IP records: We will lease the IP class of domains to ourselves and maintain mirrors of DNS records until DeNS adoption reaches a level that we judge sufficient to facilitate a “hard fork” from DNS authority. At that point, we will let the lease expire and IP class domains in DeNS will be directly managed by domain owners via DeNS smart contracts.\nArchitecture - Cardano (Technical) Protocol NFT All contract scripts will be parameterized by a Protocol NFT that uniquely identifies a UTxO which as datum contains the configuration (trusted knowledge of Plutus scripts) of the protocol. More precisely, the Protocol NFT must be paid to an unspendable validator, say ProtocolValidator, which has the following as datum.\ndata Protocol = Protocol { elementIdMintingPolicy :: ScriptHash , setElemMintingPolicy :: ScriptHash , setValidator :: ScriptHash , recordsValidator :: ScriptHash } DISCUSSION: The Protocol NFT acts as a single source of truth for the protocol. This is advantageous because of the following.\nIt allows one to easily refer to other Plutus scripts within the protocol without the worry of cyclic dependencies. It gives the a trustless setup since every Protocol NFT must be paid to the unspendable validator ProtocolValidator, so participants may verify offchain that the datum Protocol is “as expected” without the need to scan through all transactions in the blockchain. If one may extends the ProtocolValidator to be spent under controlled conditions, then since the Protocol NFT acts as the single source of truth, one may effectively update the protocol dynamically. Record Keys and Values Morally, the DeNS protocol is a cross-chain distributed Key-Value store, where the key component is a (Name,Class) pair managed by a Cardano smart-contract, and the value is a pointer to an Arweave resource which in turn contains a set of records.\n{- This data type contains all of the elements necessary to function as a key in our logical database. -} data DeNSKey = DeNSKey { densName :: ByteString -- ^ A human readable domain name , densClass :: Word16 -- ^ Each set represents a Name Universe and must be tagged w/ the class ID corresponding to that universe } -- By convention, this should be an Arweave resource address. `Nothing` indicates a deleted record newtype DeNSValue = DeNSValue { densPointer :: Maybe ByteString } Note that DeNSKeys may be ordered by defining DeNSKey n1 c1 \u003c= DeNSKey n2 c2 iff (n1, c1) \u003c= (n2, c2) i.e., DeNSKeys are ordered lexicographically using the lexicographical ordering of ByteString and the natural ordering of Word16s.\nSet Validator / ELEMENTID Minting Policy The most important invariant that the protocol must maintain is the uniqueness of names in the set of onchain keys. Unfortunately, we cannot adopt the naive approach of using an onchain List to represent this set. Because such a list could conceivably grow to include tens of millions (or more!) entries, and because traversing a list that large would assuredly exceed Cardano ExUnit limits, we are forced to adopt a more sophisticated solution. First, we will require a data type to represent entries in our set:\ndata SetDatum = SetDatum { key :: DeNSKey -- ^ This entry's key , next :: DeNSKey -- ^ The successor to key } SetElemID Minting Policy The SetValidator locks UTxOs containing SetDatum entries and is used alongside with SetElemID to represent the on-chain collection of unique keys. We initialize the set by locking a UTXO with SetDatum (DeNSKey \"\" 0) (DeNSKey ub (2^16 - 1) at the validator (which can be assumed to exist for validation checks) when minting Protocol NFT (to ensure uniqueness of the linked list) where ub is the minimal upper bound (under lexicographical ordering) of all ByteStrings that are DNS names (see 2.3.4. of RFC 1035) which is itself not a DNS name. SetElemID will identify a subset of all SetValidators on the blockchain to distinguish the SetValidators relevant to the protocol as opposed to random SetValidator addresses adversaries may have paid to.\nSetElemID will mint in two cases. The first case is the trivial initialization case – it mints only if all of the following are satisfied.\nProtocol NFT has minted.\nThere is a unique SetDatum initialized as above at SetValidator in the outputs.\nThere is no SetValidators in the inputs\nNo ElementID has minted.\nThe other case is more tricky.\nLet\nDeNSKey N C = densKey designate a new Name/Class pair for which we would like to mint an ElementID NFT SD(k,nxt)designate a SetDatum such that key = k, next = nxt INPUTS:\nA UTxO (locked at SetValidator with a SetElemID token) SD(k,nxt) where k \u003c densKey \u003c nxt OUTPUTS:\nA UTxO SD(k, densKey) (paid to the Set Validator) with a SetElemID token. A UTxO SD(densKey, nxt) (paid to the Set Validator) with a SetElemID token. MINTS:\nOne SetElemID NFT One ElementID NFT with token name blake2b_256(serialiseData(densKey)) REDEEMER:\ndata SetInsert = SetInsert { densKey :: DeNSKey } CHECKS:\nThe transaction corresponds to the above schema exactly. DISCUSSION:\nBecause the set is initialized with a lower bound and upper bound, inserting an arbitrary name n always amounts to inserting n after some known name m where m \u003c n and before some known name o s.t. n \u003c o. EXTENSIONS:\nSince the SetElemID token name isn’t used, it should be the empty string to save bytes.\nIt is possible to introduce a hierarchical ownership of names (e.g. DeNSKey 1 \"google.com.\" may be purchased only if the owner of DeNSKey 1 \"com.\" approves such a sale). We only describe the inductive case, and leave the base case up to implementations where the owner of the empty domain (for each class) would be coded directly in the smart contract. First, we will assume that a function parse :: ByteString -\u003e [ByteString] exists which maps names like \"google.com\" to [\"google\", \"com\"] i.e., parse decomposes a name into its labels, and if parse n1 is a suffix of parse n2, then we say that n2 is a subdomain of n1 (see 2.3.1). We will also assume there exists a function unparse :: [ByteString] -\u003e ByteString that is the inverse of parse. The key idea is that a subdomain must verify that the domain immediately “above” has approved purchasing the subdomain’s name.\nWe modify the datum and redeemer as follows.\ndata SetDatum = SetDatum { key :: DeNSKey , next :: DeNSKey + , ownerApproval :: CurrencySymbol + -- ^ A token which must mint in order for a subdomain to be bought } data SetInsert = SetInsert { densKey :: DeNSKey + , ownerApproval :: CurrencySymbol } Let SD(k,nxt,o) denote a SetDatum with key = k, next = nxt, ownerApproval = o.\nNow, the transaction where SetElemID mints must conform to the following schema when given redeemer SetInsert{densKey, ownerApproval} where densKey = DeNSKey N C and n:ns = parse N.\nINPUTS:\nA UTxO (locked at SetValidator with a SetElemID token) SD(k,nxt,o) where k \u003c densKey \u003c nxt REFERENCE INPUTS:\nA UTxO (locked at SetValidator with a SetElemID token) SD(unparse ns, _, domainOwner) OUTPUTS:\nA UTxO SD(k,densKey,o) (paid to the SetValidator) with a SetElemID token A UTxO SD(densKey,nxt,ownerApproval) (paid to the SetValidator) with a SetElemID token MINTS:\nOne SetElemID NFT with token name. One ElementID NFT with token name blake2b_256(serialiseData(densKey)) At least one token from the domainOwner from the reference input is minted. Note how the ownerApproval is an extra check to verify that this subdomain purchase has been approved by the domain immediately “above” it. A simple ownerApproval script could verify if some public key has signed the transaction, or some token (controlled by the owner) has been burned.\nOne may consider to not allow DeNSKeys with empty strings to be inserted.\nSetValidator validator SetValidator is the validator address which holds the elements in the logical database. It simply validates only if SetElemID mints i.e., it forwards all verifications to SetElemID.\nDISCUSSION: Since SetValidator forwards everything to SetElemID, this makes the potential for upgrading to a new SetElemID convenient as swapping to a new SetElemID' would still keep existing SetElemID already at SetValidator meaning there would be no need for a large migration of tokens.\nElementID Minting Policy The ElementID minting policy is an NFT which serves as an access control identifier in order to gate access to specific records in the virtual DeNS database.\nCHECKS::\nSetElemID mints in the same transaction DISCUSSION:\nThis forwards all verifications to SetElemID whose minting is unique w.r.t to the element inserted in the set, and ensures that this ElementID’s token name contains sufficient information to identify it with the inserted element.\nRecords Validator The records validator serves as an access control list for the virtual DeNS database. When the offchain code reconstructs the database from Cardano keys and Arweave values, it treats the records locked at the Records validator identified with a ElementID token as the source of authority. That is: Only records locked at the records validator are used to construct the database used in a DeNS resolver.\nPARAMETERS:\nThe Protocol NFT DATUM:\nThe Records Validator datum functions as the key in our virtual database. To update or create a record, a DeNS user simply adjusts the reference for the class and name that they own. To delete a record, the user submits a transaction with an output datum where the reference field is Nothing.\ndata RecordDatum = RecordDatum { class :: Word16 , name :: ByteString , reference :: Maybe ByteString -- ^ an Arweave address , owner :: PubKeyHash } The offchain code that constructs the DeNS database will always treat the most recent record associated with a given name as authoritative, and consequently we do not need to distinguish between record creation and record deletion. (Unlike the SetValidator, we do not need a simulated Map or Set).\nINPUTS:\nA UTxO containing a NFT where the AssetClass consists of a CurrencySymbol == the hash of the ElementID MintingPolicy and where the token name is (or should be) == the blake2b hash calculated from blake2b_256 (serialiseData(redeemer.class , redeemer.name)) OUTPUTS:\nA UTxO, paid to the Records Validator, which contains the RecordDatum passed by the user MINTS: N/A\nCHECKS:\nThe transaction is signed by owner DISCUSSION: Since the owner owns the token, this validator gives them “free reign” to update it as they please. In practise, to not confuse offchain code and devalue one’s own Records (by e.g. giving it to someone else for free), one would most likely want to check the following conditions as well\nThe NFT in the inputs contains a token that satisfies the constraints outlined above in the section The output contains a single UTxO with an inline RecordDatum datum which is equal to the input passed in by the user This output UTxO is paid to the validator Architecture - Offchain (Technical) The offchain infrastructure needs to provide the following services.\nEfficient UTxO queries. Of course, we must efficiently provide UTxOs for the onchain code to build transactions. In particular, some of the special needs of the onchain protocol includes:\nAn efficient mapping from CurrencySymbols/TokenNames to the UTxOs which the token resides at.\nAn efficient mapping from a DeNSKey, say k, to the UTxO in the set with the largest DeNSKey, say lb, s.t. lb \u003c k.\nProvide DNS records to query. This is straightforward – we obviously need to a method to provide DNS records compatible with existing DNS systems.\nEfficient UTxO queries Due to the peculiar needs of the onchain protocol, we will most likely need to adapt an existing chain indexer. Off the shelf solutions like Kupo (which is used internally by CTL) unfortunately supports querying UTxOs via “patterns” which in particular do not satisfy the requirement of efficiently mapping DeNSKeys to a particular UTxO in the sense mentioned above.\nAs such, we must maintain our own index to query UTxOs by e.g. maintaining an SQL database such as PostgreSQL (where note that most relational databases by construction can efficiently query achieve our desired DeNSKey query) which listens for “events” on the Cardano blockchain and updates its tables appropriately.\nOf course, we can write our own chain indexer, but it’s probably better to build off existing work such as:\nAdapting the more chain flexible indexers such as oura which filters events on the blockchain according to patterns and outputs the values to a “sink” which updates our own database. Note that we could also use marconi, but it appears to be under heavy development.\nInteracting with ogmios which provides a convenient websockets to interact with the blockchain node, and we could update our database based on the information obtained by the websockets.\nProviding DNS records We will piggyback off of existing DNS systems. This has the benefit of allowing ease of integration to existing DNS systems. We considered the following two existing DNS systems.\nBIND 9 is the first, oldest, and most commonly deployed solution. This has the immediate benefit that network engineers will already be familiar with its deployment to ease adoption of DeNS. This is an all-in-one solution which combines both the recursive resolver, and the authoritative server. Unfortunately, in DeNS, since the blockchain is the single source of truth of ownership for the RRs, there is no need to use the recursive resolver part. It is possible to disable the recursive resolver in BIND 9, but we opted with the more modular PowerDNS solution described below.\nPowerDNS consists of two parts: the authoritative server, and the recursor. The authoritative server answers questions about the domains it knows about (from its database), and importantly will not go out on the net to resolve queries about other domains. On the other hand, the recursor has no knowledge of domains itself, but will always consult other authoritative servers to answer questions given to it. Indeed, DeNS would like to integrate with only the authoritative server part of PowerDNS (ignoring the recursor), where DeNS will fill up the authoritative server’s database with its own DNS records.\nOf the two existing solutions, we believe that PowerDNS’s modularity of splitting the authoritative server and the recursor into separate entities makes it a better fit to integrate into DeNS since DeNS only needs the authoritative server functionality.\nPowerDNS allows one to implement a remote backend to propagate information about RRs to PowerDNS via a JSON/RPC API. So, we propose to implement a remote backend which will service RRs from the database to a PowerDNS authoritative server to answer the DNS queries.\nFinally, the only question that remains is how updates from the blockchain should propagate to the authoritative server. We propose to piggyback back on top of the chain indexer from the previous section where we listen for the event of set changes, and on the occurrence of such event, we update the DNS records.\n","categories":"","description":"","excerpt":"Requirements (Conceptual) The DeNS protocol must support a small list …","ref":"/DeNS/docs/architecture/architecture/","tags":"","title":"Technical Specification"},{"body":" DeNS Query provides an HTTP interface for accessing the UTxOs stored in the database.\nAuthentication Some endpoints provided by DeNS Query are exposed internal functionalities to and are made available to facilitate testing and development.\nImportant To prevent malicious interactions/modifications of DeNS Query’s database, it is therefore expected that these endpoints must NOT be exposed publicly (i.e., not accessible to end-users). For this to be effective, a HTTPS reverse proxy may be used to:\nensure that proper encryption is enforced;\nguarantee host authentication; and\nmake sure that only user-specific endpoints are exposed for the public.\nBelow is a list of these internal endpoints that should not be exposed in the public API:\nPOST Set Protocol NFT\nHTTP Endpoints POST Query Set Insertion UTxO Method POST\nURL /api/query-set-insertion-utxo\nReturns the UTxO to spend in order to purchase the given domain from the smart contracts.\nExample request { \"name\": \"7461796C6F7273776966742E636F6D\" (1) } Hex encoded domain name one wishes to purchase\nExample response { \"name\": \"Ok\", \"fields\": [ { \"name\": \"676F6F676C652E636F6D\", (1) \"pointer\": (2) { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" }, \"txOutRef\": (3) { \"txOutRef\": (4) \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"txOutRefIx\": 69 (5) } } ] } Hex encoded largest purchased domain name which is lexicograpically strictly less than the provided domain name.\nAsset class which identifies the UTxOs of RRs\nTransaction output that this information resides at\nHex encoded transaction hash\nInteger index\nErrors Code\nMessage\nDescription\n400\nDomain name already exists error response\nThrown if the domain name to purchase has already been purchased\n500\nNo set elements found\nThrown if there are no UTxOs to spend in the set (most likely a misconfigured protocol)\nDomain name already exists error response No set elements found POST Protocol UTxO Method POST\nURL /api/query-protocol-utxo\nReturns the UTxO which holds the Protocol type i.e., trusted information of the DeNS protocol.\nExample request { } Example response { \"name\": \"Ok\", \"fields\": [ { \"txOutRef\": (1) { \"txOutRef\": (2) \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"txOutRefIx\": 69 (3) }, \"protocol\": (4) { \"elementIdMintingPolicy\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"setElemMintingPolicy\" : \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"setValidator\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\", \"recordsValidator\": \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\" } } ] } Transaction output that this information resides at\nHex encoded transaction hash\nInteger index\nJSON object of hex encoded script hashes (28 bytes)\nErrors Code\nMessage\nDescription\n500\nNo protocol utxo found\nThrown if there is no UTxO for the protocol\nNo protocol utxo found POST Set Protocol NFT Method POST\nURL /api/set-protocol-nft\nSets the protocol NFT to the provided protocol NFT returning the new protocol NFT that DeNS Query now follows. In other words, recalling that all instances of the DeNS protocol are uniquely identified by a protocol NFT, setting the protocol NFT to a new protocol NFT therefore changes the instance of the DeNS protocol that this DeNS Query server follows.\nExample request { \"protocolNft\": { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } Example response { \"name\": \"Ok\", \"fields\": [ { \"protocolNft\": { \"currency_symbol\": \"0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F\", \"token_name\": \"\" } } ] } LambdaBuffers All datum described in the requests and responses in HTTP Endpoints have an associated LambdaBuffers type with generated JSON parsers. Details can be found in the LambdaBuffers schema file given below\nLambdaBuffers schema file module Dens.Server import Prelude (Eq, Json, Text) import Plutus.V1 (TxOutRef, AssetClass, Bytes) import Dens.Db (DensProtocolUtxo, DensSetUtxo) --------------------------------------------------- -- Response type --------------------------------------------------- sum Response a = Ok a | Failed ResponseFailed record ResponseFailed = { error: Text } derive Eq (Response a) derive Json (Response a) derive Eq ResponseFailed derive Json ResponseFailed --------------------------------------------------- -- Set insertion request / response --------------------------------------------------- record QueryDensSetInsertionUtxoRequest = { name : Bytes } prod QueryDensSetInsertionUtxoResponse = (Response DensSetUtxo) derive Eq QueryDensSetInsertionUtxoRequest derive Json QueryDensSetInsertionUtxoRequest derive Eq QueryDensSetInsertionUtxoResponse derive Json QueryDensSetInsertionUtxoResponse --------------------------------------------------- -- Set query request / response --------------------------------------------------- -- TODO(jaredponn): implementing this would be useful for updates, but we don't -- support this now. -- record QueryDensSettxoRequest = { name : Bytes } -- prod QueryDensSetUtxoResponse = (Response DensSetUtxo) -- -- derive Eq QueryDensSetUtxoRequest -- derive Json QueryDensSetUtxoRequest -- -- derive Eq QueryDensSetUtxoResponse -- derive Json QueryDensSetUtxoResponse --------------------------------------------------- -- Protocol info query / response --------------------------------------------------- -- TODO(jaredponn): LB doesn't like JSON objects for empty records. I'll PR -- this in LB. -- record QueryDensProtocolUtxoRequest = { } prod QueryDensProtocolUtxoResponse = (Response DensProtocolUtxo) -- derive Eq QueryDensProtocolUtxoRequest -- derive Json QueryDensProtocolUtxoRequest derive Eq QueryDensProtocolUtxoResponse derive Json QueryDensProtocolUtxoResponse --------------------------------------------------- -- Set protocol NFT query /response --------------------------------------------------- record SetProtocolNftRequest = { protocolNft: AssetClass } prod SetProtocolNftResponse = (Response SetProtocolNftRequest) derive Eq SetProtocolNftRequest derive Json SetProtocolNftRequest derive Eq SetProtocolNftResponse derive Json SetProtocolNftResponse ","categories":"","description":"","excerpt":" DeNS Query provides an HTTP interface for accessing the UTxOs stored …","ref":"/DeNS/docs/dens-query/http_api/","tags":"","title":"HTTP API"},{"body":" A single participant in the protocol will need to initialize the DeNS protocol for everyone.\nInitializing the DeNS protocol dens-transactions-cli \\ init \\ --ogmios-host 127.0.0.1 \\ --ogmios-port 1337 \\ --network Preview \\ --protocol-nft-tx-out-ref \"5969b450ec00019044fbcb1cd5973cc80a47b1507e2e0e14f3e6e4a2f23cdabd#0\" \\ --dens-query-socket-path /ipc/dens-query/dens-query.sock \\ --private-key-bech32 ed25519_sk1p8874wgza2c5yxytucugt2k2mrw3l3gkpg6ezxn498smerqh8j0qe078pu Note This will output the protocol’s token which must be used in all `dens-query-cli`s' configuration files that follow this instance of the DeNS protocol. ","categories":"","description":"","excerpt":" A single participant in the protocol will need to initialize the DeNS …","ref":"/DeNS/docs/dens-transactions/init/","tags":"","title":"Initialization"},{"body":" Note Readers may skip this section. DeNS query uses PostgreSQL with many PostgreSQL specific extensions. In particular, the PostgreSQL specific extensions were used to respond to blockchain rollbacks where the blockchain will rollback to a particular block requiring the protocol to undo all the changes from the present to the block to rollback to.\nDatabase schema source code -- = Overview -- For each \"kind of UTxO\" for the dens protocol, we create a table for it e.g. -- we have tables -- - `+dens_set_utxos+` -- - `+dens_elem_ids+` -- - `+dens_protocol_utxos+` -- We call such a table a _dens table_. -- Each of these dens tables has a foreign key to `+tx_out_refs+` s.t. when a -- UTxO gets spent, we may simply delete the corresponding transaction output -- `+tx_out_refs+` where the deletion will cascade down to the dens table. -- Note that the `+tx_out_refs+` has foreign keys to the `+blocks+` table. -- -- To handle rollbacks (recall a rollback is when the blockchain \"goes back\" to -- a previous block state), we have the `+undo_log+` table which associates -- blocks with the inverse operation of the SQL statements that changed dens -- tables (or the `+tx_out_refs+`/`+blocks+` table). -- Thus, rolling back amounts to executing each of the SQL statements stored in -- `+undo_log+` until we reach the block that we must roll back to. -- Finally, to maintain the `+undo_log+`, we essentially create a \"higher order -- function\" which creates a trigger for each of the dens tables (and the -- `+tx_out_refs+`/`+blocks+` table) which records the inverse SQL operation in -- the `+undo_log+` table. -- One wrinkle with the triggers is that cascaded SQL operations don't execute -- the triggers in the \"right order\" e.g. if we have table A and table B where -- B has a foreign key to A, and we delete something in A, the trigger for A -- will run, then the trigger for B will run -- so undoing will temporarily -- violate the foreign key constraint. Hence, why we always have `+DEFERRABLE+` -- set for foreign keys. -- -- Finally, this schema assumes that we are only following a single DeNS -- protocol. Thus, it assumes that there is a unique protocol NFT we are -- interested in following -- see the table `+dens_protocol_nft+` for details. -- -- -- = References -- -- * [#ogmios] https://ogmios.dev/api/ ----------------------------------------------------------------------------- -- = Types ----------------------------------------------------------------------------- DO LANGUAGE plpgsql $body$ BEGIN CREATE TYPE asset_class_type AS ( currency_symbol bytea, token_name bytea ); CREATE DOMAIN asset_class AS asset_class_type CONSTRAINT currency_symbol_not_null CHECK (((VALUE).currency_symbol IS NOT NULL)) CONSTRAINT token_name_not_null CHECK (((VALUE).token_name IS NOT NULL)) -- https://github.com/IntersectMBO/plutus/blob/1.16.0.0/plutus-ledger-api/src/PlutusLedgerApi/V1/Value.hs#L75-L92 CONSTRAINT currency_symbol_length CHECK ((octet_length((VALUE).currency_symbol) = 0) OR (octet_length((VALUE).currency_symbol) = 28)) -- https://github.com/IntersectMBO/plutus/blob/1.16.0.0/plutus-ledger-api/src/PlutusLedgerApi/V1/Value.hs#L99-L112 CONSTRAINT token_name_length CHECK (octet_length((VALUE).token_name) \u003c= 32); EXCEPTION WHEN duplicate_object THEN null; END $body$; ----------------------------------------------------------------------------- -- = Tables for general information about the blockchain ----------------------------------------------------------------------------- -- All blocks in the blockchain. CREATE TABLE IF NOT EXISTS blocks ( block_slot bigint NOT NULL, block_id bytea NOT NULL, PRIMARY KEY (block_id, block_slot) ); -- Transaction outputs relevant to the dens tables CREATE TABLE IF NOT EXISTS tx_out_refs ( tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, block_slot bigint NOT NULL, block_id bytea NOT NULL, FOREIGN KEY (block_id, block_slot) REFERENCES blocks (block_id, block_slot) ON DELETE CASCADE DEFERRABLE, -- https://github.com/IntersectMBO/plutus/blob/1.16.0.0/plutus-ledger-api/src/PlutusLedgerApi/V1/Tx.hs#L51-L65 CONSTRAINT tx_id_length_is_32 CHECK (octet_length(tx_out_ref_id) = 32), PRIMARY KEY (tx_out_ref_id, tx_out_ref_idx) ); ----------------------------------------------------------------------------- -- = Tables for the protocol ----------------------------------------------------------------------------- ----------------------------------------------------------------------------- -- == Table for the Linked list for associating domain names to RRs ----------------------------------------------------------------------------- -- Linked list set data structure CREATE TABLE IF NOT EXISTS dens_set_utxos ( -- Unique identifier for the names id bigserial UNIQUE, -- name for the DNS record that is owned name bytea UNIQUE, -- Token which associates this `+name+` with a validator address which -- actually holds (a reference) to the RRs. pointer asset_class NOT NULL, tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, PRIMARY KEY (tx_out_ref_id, tx_out_ref_idx), FOREIGN KEY (tx_out_ref_id, tx_out_ref_idx) REFERENCES tx_out_refs (tx_out_ref_id, tx_out_ref_idx) ON DELETE CASCADE DEFERRABLE ); -- Index s.t. one can efficiently query if change has happened in the -- dens_set_utxos CREATE INDEX IF NOT EXISTS dens_set_utxos_asset_class ON dens_set_utxos (pointer); -- Index s.t. one can efficiently query which UTxO to spend CREATE INDEX IF NOT EXISTS dens_set_utxos_name ON dens_set_utxos (name); ----------------------------------------------------------------------------- -- == Table for representing the UTxOs which contain RRs ----------------------------------------------------------------------------- -- `+TxOutRef+`s which contain the dens_set_utxos(pointer) -- i.e., these are the UTxOs which identify the transactions which contain -- transaction outputs that contain RRs as datum. CREATE TABLE IF NOT EXISTS dens_elem_ids ( id bigserial UNIQUE, tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, asset_class asset_class NOT NULL, PRIMARY KEY(id), UNIQUE (asset_class), UNIQUE (tx_out_ref_id, tx_out_ref_idx, asset_class), FOREIGN KEY (tx_out_ref_id, tx_out_ref_idx) REFERENCES tx_out_refs (tx_out_ref_id, tx_out_ref_idx) ON DELETE CASCADE DEFERRABLE ); CREATE INDEX IF NOT EXISTS dens_elem_ids_asset_classes ON dens_elem_ids(asset_class); -- The list of RRs at `+DensValidator+`s addresses i.e., this forms a -- . M:1 relationship of `+dens_rrs+` to `+dens_elem_ids+` -- -- NOTE:(jaredponn): so unlike the rest of the tables, the UTxOs we are -- interested in are controlled by how an asset class at `+dens_elem_ids+` -- is traded i.e., -- -- . If the asset class at `+dens_elem_ids+` is traded (i.e., if this -- UTxO is consumed), then the RRs are deleted -- -- Contrast this to how all other tables have FKs to the `+tx_out_refs+` table -- -- NOTE(jaredponn): this loosely follows the records table in -- \u003chttps://github.com/PowerDNS/pdns/blob/0b6eb67e14ce894e8286c0993e393b1191411c96/modules/gpgsqlbackend/schema.pgsql.sql\u003e -- NOTE(jaredponn): the only DNS backend we support is PowerDNS. The following -- are useful docs: -- . \u003chttps://github.com/PowerDNS/pdns/blob/0b6eb67e14ce894e8286c0993e393b1191411c96/modules/gpgsqlbackend/schema.pgsql.sql\u003e -- for the schema -- . \u003chttps://github.com/PowerDNS/pdns/blob/0b6eb67e14ce894e8286c0993e393b1191411c96/modules/gpgsqlbackend/gpgsqlbackend.cc\u003e -- . In the future, it'll probably be a reasonable idea to write up our own Cardano backend. -- See over here: \u003chttps://doc.powerdns.com/authoritative/appendices/backend-writers-guide.html\u003e for details CREATE TABLE IF NOT EXISTS dens_rrs ( id bigserial, -- The type of the RR e.g. `+A+`, `+AAAA+`, etc. type varchar(10) NOT NULL, ttl int NOT NULL, content varchar(65535) NOT NULL, dens_elem_id bigserial, PRIMARY KEY(id), FOREIGN KEY (dens_elem_id) REFERENCES dens_elem_ids(id) ON DELETE CASCADE DEFERRABLE ); ----------------------------------------------------------------------------- -- == Table for the protocol UTxO ----------------------------------------------------------------------------- CREATE TABLE IF NOT EXISTS dens_protocol_utxos ( element_id_minting_policy bytea NOT NULL, set_elem_minting_policy bytea NOT NULL, set_validator bytea NOT NULL, records_validator bytea NOT NULL, tx_out_ref_id bytea NOT NULL, tx_out_ref_idx bigint NOT NULL, PRIMARY KEY (tx_out_ref_id, tx_out_ref_idx), FOREIGN KEY (tx_out_ref_id, tx_out_ref_idx) REFERENCES tx_out_refs (tx_out_ref_id, tx_out_ref_idx) ON DELETE CASCADE DEFERRABLE ); ----------------------------------------------------------------------------- -- == Table for the protocol NFT ----------------------------------------------------------------------------- -- Note that we assume that we are only following a single instance of the DeNS -- protocol in this schema, so really _all_ DeNS tables depend on this table; -- and hence have a foreign key to this table. -- But, to simplify the schema, we only allow at most one dens_protocol_nft to -- exist, and hence we don't write this foreign key dependency explicitly in -- the tables. -- See `+dens_set_protocol_nft+` for details. CREATE TABLE IF NOT EXISTS dens_protocol_nft( at_most_one boolean PRIMARY KEY DEFAULT TRUE, asset_class asset_class NOT NULL, CONSTRAINT at_most_one CHECK (at_most_one) ); ----------------------------------------------------------------------------- -- = Tables for the undo log ----------------------------------------------------------------------------- -- Associates a block (the block id and block slot) with an SQL statement to -- undo something. -- NOTE: future versions can shrink the length of undo_log and make it -- based on the maximum length of the rollback to save some memory. -- See https://cips.cardano.org/cip/CIP-9/ for details. CREATE TABLE IF NOT EXISTS undo_log ( seq bigserial, block_slot bigint NOT NULL, block_id bytea NOT NULL, undo_statement text NOT NULL, FOREIGN KEY (block_id, block_slot) REFERENCES blocks (block_id, block_slot) ON DELETE CASCADE DEFERRABLE, PRIMARY KEY (seq) ); CREATE INDEX IF NOT EXISTS undo_log_block_id_and_block_slot ON undo_log (block_slot, block_id); -- Gets the most recent block CREATE OR REPLACE FUNCTION get_most_recent_block() RETURNS blocks AS $body$ DECLARE most_recent_block blocks; BEGIN SELECT blocks.block_slot, blocks.block_id INTO most_recent_block FROM blocks WHERE blocks.block_slot = (SELECT max(block_slot) FROM blocks); RETURN most_recent_block; END $body$ LANGUAGE plpgsql; -- Given a `+table_name+`, returns `+\u003ctable_name\u003e_undo_insert+`. This exists to -- ensure that we have a consistent way of generating the trigger / function -- name associated with a table. CREATE OR REPLACE FUNCTION create_undo_insert_name(table_name text) RETURNS text AS $body$ BEGIN RETURN table_name || '_undo_insert'; END $body$ LANGUAGE plpgsql; -- Creates a function and trigger with the name `+table_name_undo_insert+` -- which on insertion to `+table_name+`, assuming that `+undo_log.freeze_log+` -- is not true, appends an SQL statement of the form -- --- -- format -- ( $$ DELETE FROM table_name WHERE primary_key1 = %L AND ... primary_keyN = %L $$ -- , NEW.primary_key1 -- , ... -- , NEW.primary_keyN -- ) -- --- -- to `+undo_log+` associated with the most recently added block (if it exists, -- otherwise we do nothing). CREATE OR REPLACE FUNCTION create_table_undo_insert(table_name text) RETURNS void AS $body$ DECLARE name text := create_undo_insert_name(table_name); sql_is_primary_keys text; sql_new_primary_keys text; BEGIN CREATE TEMP TABLE table_primary_keys( primary_key text ) ON COMMIT DROP; -- See \u003chttps://wiki.postgresql.org/wiki/Retrieve_primary_key_columns\u003e -- for details INSERT INTO table_primary_keys SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = CAST (table_name AS regclass) AND i.indisprimary; -- Create a string of the form -- --- -- primary_key1 = %L AND primary_key2 = %L ... AND primary_keyN = %L -- --- SELECT string_agg(format('%I = %%L', primary_key), ' AND ' ORDER BY primary_key ASC) INTO STRICT sql_is_primary_keys FROM table_primary_keys; -- Create a string of the form -- --- -- NEW.primary_key1, NEW.primary_key2, ..., NEW.primary_keyN -- --- SELECT string_agg(format('NEW.%I', primary_key), ',' ORDER BY primary_key ASC) INTO STRICT sql_new_primary_keys FROM table_primary_keys; EXECUTE format( $undo_function$ CREATE OR REPLACE FUNCTION %I() RETURNS trigger AS $$ DECLARE most_recent_block record := get_most_recent_block(); BEGIN IF current_setting('undo_log.freeze_log', TRUE) = CAST(TRUE AS TEXT) THEN RETURN NEW; END IF; IF most_recent_block IS NOT NULL THEN -- if there is no block, then we can't associate the undo log with anything INSERT INTO undo_log (seq, block_slot, block_id, undo_statement) VALUES (DEFAULT, most_recent_block.block_slot, most_recent_block.block_id, format(%L, %s)); END IF; RETURN NEW; END $$ LANGUAGE plpgsql; $undo_function$, name, format('DELETE FROM %I WHERE %s', table_name, sql_is_primary_keys), sql_new_primary_keys ); EXECUTE format( $undo_trigger$ CREATE OR REPLACE TRIGGER %I AFTER INSERT ON %I FOR EACH ROW EXECUTE FUNCTION %I(); $undo_trigger$, name, table_name, name ); DROP TABLE IF EXISTS table_primary_keys; END $body$ LANGUAGE plpgsql; -- Given a `+table_name+`, returns `+\u003ctable_name\u003e_undo_delete+`. This exists to -- ensure that we have a consistent way of generating the trigger / function -- name associated with a table. CREATE OR REPLACE FUNCTION create_undo_delete_name(table_name text) RETURNS text AS $body$ BEGIN RETURN table_name || '_undo_delete'; END $body$ LANGUAGE plpgsql; -- Creates a function and trigger with the name `+table_name_undo_delete+` -- which on deletion to `+table_name+`, assuming that `+undo_log.freeze_log+` -- is not true, append an SQL statement of the form -- --- -- format -- ( $$ INSERT INTO table_name VALUES ((CAST (%L AS table_name)).*) $$ -- , NEW -- ) -- --- -- to `+undo_log+` associated with the most recently added block (if it exists, -- otherwise we do nothing). CREATE OR REPLACE FUNCTION create_table_undo_delete(table_name text) RETURNS void AS $body$ DECLARE name text := create_undo_delete_name(table_name); BEGIN EXECUTE format( $undo_function$ CREATE OR REPLACE FUNCTION %I() RETURNS trigger AS $$ DECLARE most_recent_block record := get_most_recent_block(); BEGIN IF current_setting('undo_log.freeze_log', TRUE) = CAST(TRUE as TEXT) THEN RETURN OLD; END IF; IF most_recent_block IS NOT NULL THEN -- if there is no block, then we can't associate the undo log with anything INSERT INTO undo_log (seq, block_slot, block_id, undo_statement) VALUES (DEFAULT, most_recent_block.block_slot, most_recent_block.block_id, format(%L, OLD)); END IF; RETURN OLD; END $$ LANGUAGE plpgsql; $undo_function$, name, format('INSERT INTO %I VALUES ((CAST (%%L AS %I)).*)', table_name, table_name) ); EXECUTE format( $undo_trigger$ CREATE OR REPLACE TRIGGER %I AFTER DELETE ON %I FOR EACH ROW EXECUTE FUNCTION %I(); $undo_trigger$, name, table_name, name ); END $body$ LANGUAGE plpgsql; -- Given a `+table_name+`, returns `+\u003ctable_name\u003e_undo_update+`. This exists to -- ensure that we have a consistent way of generating the trigger / function -- name associated with a table. CREATE OR REPLACE FUNCTION create_undo_update_name(table_name text) RETURNS text AS $body$ BEGIN RETURN table_name || '_undo_update'; END $body$ LANGUAGE plpgsql; -- Creates a function and trigger with the name `+table_name_undo_update+` -- which on update to `+table_name+`, assuming that `+undo_log.freeze_log+` -- is not true, appends an SQL statement of the form -- --- -- format -- ( $$ UPDATE table_name SET column_name1 = %L, ..., column_nameN = %L WHERE primary_key1 = %L AND ... AND primary_keyM = %L; -- , OLD.column_name1 -- , ... -- , OLD.column_nameN -- , NEW.primary_key1 -- , ... -- , NEW.primary_keyM -- ) -- --- -- to `+undo_log+` associated with the most recently added block (if it exists, -- otherwise we do nothing). CREATE OR REPLACE FUNCTION create_table_undo_update(table_name text) RETURNS void AS $body$ DECLARE name text := create_undo_update_name(table_name); sql_is_primary_keys text; sql_new_primary_keys text; sql_set_columns text; sql_old_columns text; BEGIN -- = SQL strings relating to the primary keys CREATE TEMP TABLE table_primary_keys( primary_key text ) ON COMMIT DROP; -- See \u003chttps://wiki.postgresql.org/wiki/Retrieve_primary_key_columns\u003e -- for details INSERT INTO table_primary_keys SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = CAST (table_name AS regclass) AND i.indisprimary; -- Create a string of the form -- --- -- primary_key1 = %L AND primary_key2 = %L ... AND primary_keyN = %L -- --- SELECT string_agg(format('%I = %%L', primary_key), ' AND ' ORDER BY primary_key ASC) INTO STRICT sql_is_primary_keys FROM table_primary_keys; -- Create a string of the form -- --- -- NEW.primary_key1, NEW.primary_key2, ..., NEW.primary_keyN -- --- SELECT string_agg(format('NEW.%I', primary_key), ',' ORDER BY primary_key ASC) INTO STRICT sql_new_primary_keys FROM table_primary_keys; -- = SQL strings relating to all columns CREATE TEMP TABLE table_column_names( column_name text ) ON COMMIT DROP; INSERT INTO table_column_names SELECT i.attname FROM pg_attribute i WHERE i.attrelid = CAST (table_name AS regclass) AND i.attnum \u003e 0 AND NOT i.attisdropped; -- Create a string of the form -- --- -- column_name1 = %L, column_name2 = %L, ..., column_nameN = %L -- --- SELECT string_agg(format('%I = %%L', column_name), ',' ORDER BY column_name ASC) INTO STRICT sql_set_columns FROM table_column_names; -- Create a string of the form -- --- -- OLD.column_name1, column_name2, ..., OLD.column_nameN -- --- SELECT string_agg(format('OLD.%I', column_name), ',' ORDER BY column_name ASC) INTO STRICT sql_old_columns FROM table_column_names; EXECUTE format( $undo_function$ CREATE OR REPLACE FUNCTION %I() RETURNS trigger AS $$ DECLARE most_recent_block record := get_most_recent_block(); BEGIN IF current_setting('undo_log.freeze_log', TRUE) = CAST(TRUE AS TEXT) THEN RETURN NEW; END IF; IF most_recent_block IS NOT NULL THEN -- if there is no block, then we can't associate the undo log with anything INSERT INTO undo_log (seq, block_slot, block_id, undo_statement) VALUES (DEFAULT, most_recent_block.block_slot, most_recent_block.block_id, format(%L, %s, %s)); END IF; RETURN NEW; END $$ LANGUAGE plpgsql; $undo_function$, name, format('UPDATE %I SET %s WHERE %s', table_name, sql_set_columns, sql_is_primary_keys), sql_old_columns, sql_new_primary_keys ); EXECUTE format( $undo_trigger$ CREATE OR REPLACE TRIGGER %I AFTER UPDATE ON %I FOR EACH ROW EXECUTE FUNCTION %I(); $undo_trigger$, name, table_name, name ); DROP TABLE IF EXISTS table_primary_keys; DROP TABLE IF EXISTS table_column_names; END $body$ LANGUAGE plpgsql; -- Freezes the `+undo_log+` i.e., stops triggers from automatically adding -- things to the `+undo_log+` in the current transaction CREATE OR REPLACE FUNCTION freeze_undo_log() RETURNS void as $body$ BEGIN SET LOCAL undo_log.freeze_log = TRUE; END $body$ LANGUAGE plpgsql; -- Unfreezes the `+undo_log+` i.e., allows things to be added to the -- `+undo_log+` again in the current transaction CREATE OR REPLACE FUNCTION unfreeze_undo_log() RETURNS void as $body$ BEGIN SET LOCAL undo_log.freeze_log = FALSE; END $body$ LANGUAGE plpgsql; -- Roll backs the database to the given block i.e., -- Using the `+undo_log+`, execute all `+undo_statement+` _strictly after_ the -- provided block, and delete such rows from the `+undo_log+`. CREATE OR REPLACE FUNCTION undo_log_rollback_to(block_slot bigint, block_id bytea) RETURNS void AS $body$ DECLARE to_undo record; BEGIN SET CONSTRAINTS ALL DEFERRED; PERFORM freeze_undo_log(); FOR to_undo IN WITH deleted AS( DELETE FROM undo_log WHERE undo_log.block_slot \u003e undo_log_rollback_to.block_slot RETURNING * ) SELECT * FROM deleted ORDER BY seq DESC LOOP IF to_undo.undo_statement IS NOT NULL THEN EXECUTE to_undo.undo_statement; END IF; END LOOP; PERFORM unfreeze_undo_log(); END $body$ LANGUAGE plpgsql; ----------------------------------------------------------------------------- -- = Undo log triggers ----------------------------------------------------------------------------- SELECT create_table_undo_insert('blocks'); SELECT create_table_undo_delete('blocks'); SELECT create_table_undo_insert('tx_out_refs'); SELECT create_table_undo_delete('tx_out_refs'); SELECT create_table_undo_update('tx_out_refs'); SELECT create_table_undo_insert('dens_set_utxos'); SELECT create_table_undo_delete('dens_set_utxos'); SELECT create_table_undo_update('dens_set_utxos'); SELECT create_table_undo_insert('dens_elem_ids'); SELECT create_table_undo_delete('dens_elem_ids'); SELECT create_table_undo_update('dens_elem_ids'); SELECT create_table_undo_insert('dens_rrs'); SELECT create_table_undo_delete('dens_rrs'); SELECT create_table_undo_update('dens_rrs'); SELECT create_table_undo_insert('dens_protocol_utxos'); SELECT create_table_undo_delete('dens_protocol_utxos'); SELECT create_table_undo_update('dens_protocol_utxos'); ----------------------------------------------------------------------------- -- = Helper functions ----------------------------------------------------------------------------- -- If the provided asset class (currency symbol / token name) matches the -- existing asset class in the `+dens_protocol_nft+` table, do nothing. -- Otherwise, overwrite the existing `+dens_protocol_nft+` CREATE OR REPLACE FUNCTION dens_set_protocol_nft(currency_symbol bytea, token_name bytea) RETURNS dens_protocol_nft AS $body$ DECLARE old_protocol_nft dens_protocol_nft; new_protocol_nft dens_protocol_nft; BEGIN SELECT * INTO old_protocol_nft FROM dens_protocol_nft; INSERT INTO dens_protocol_nft(asset_class) VALUES(CAST(ROW(dens_set_protocol_nft.currency_symbol, dens_set_protocol_nft.token_name) AS asset_class)) ON CONFLICT (at_most_one) DO UPDATE SET asset_class = (EXCLUDED).asset_class; SELECT * INTO STRICT new_protocol_nft FROM dens_protocol_nft; IF old_protocol_nft IS NULL THEN RETURN new_protocol_nft; END IF; IF (old_protocol_nft).asset_class = (new_protocol_nft).asset_class THEN RETURN new_protocol_nft; END IF; RETURN new_protocol_nft; END $body$ LANGUAGE plpgsql; -- Resets the database if the current protocol NFT stored in the database -- differs from the provided NFT, and returns the current protocol NFT stored -- in the database CREATE OR REPLACE FUNCTION dens_sync_protocol_nft(currency_symbol bytea, token_name bytea) RETURNS dens_protocol_nft AS $body$ DECLARE current_protocol_nft dens_protocol_nft; BEGIN SELECT * INTO current_protocol_nft FROM dens_protocol_nft; IF current_protocol_nft IS NULL THEN -- Clear all tables if there is no current protocol NFT TRUNCATE blocks * RESTART IDENTITY CASCADE; RETURN ROW(true, currency_symbol,token_name); END IF; -- If the current protocol NFT matches the provided NFT, we're good, so do nothing and return IF (current_protocol_nft).asset_class = ROW(currency_symbol, token_name) THEN RETURN current_protocol_nft; END IF; TRUNCATE blocks * RESTART IDENTITY CASCADE; RETURN current_protocol_nft; END $body$ LANGUAGE plpgsql; -- Gets a collection of the most recent points suitable for resynchronizing -- with the blockchain after shutting down. -- NOTE: future versions may use binary search to find the first common point. -- This requires a somewhat tricky interaction between ogmios / postgres; and -- it's unclear if this would actually be better at all. CREATE OR REPLACE FUNCTION dens_recent_points() RETURNS SETOF blocks AS $body$ BEGIN RETURN QUERY SELECT block_slot, block_id FROM blocks ORDER BY blocks.block_slot DESC LIMIT 64; END $body$ LANGUAGE plpgsql; -- Tests if the provided name is valid. See Section 3.5 of -- \u003chttps://datatracker.ietf.org/doc/html/rfc1034\u003e. -- Moreover, differing from the specification, we only allow names to be lower -- case. -- -- For compatibility with DNS backends like PowerDNS, we must ensure: -- - names are NEVER terminated with a trailing `.`, -- - with the exception of the root zone, which must have the name of `.` -- See \u003chttps://doc.powerdns.com/authoritative/backends/generic-sql.html#:~:text=The%20generic%20SQL%20backends%20(like,needed%20to%20cover%20all%20needs.\u003e CREATE OR REPLACE FUNCTION dens_is_valid_name(name bytea) RETURNS boolean AS $body$ BEGIN RETURN encode(name, 'escape') SIMILAR TO '.|(([a-z]([-a-z0-9]*[a-z0-9])?)(.([a-z]([-a-z0-9]*[a-z0-9])?))*)'; END $body$ LANGUAGE plpgsql; ","categories":"","description":"","excerpt":" Note Readers may skip this section. DeNS query uses PostgreSQL with …","ref":"/DeNS/docs/dens-query/database_schema/","tags":"","title":"Database Schema"},{"body":" This section describes the design of all components of DeNS.\n","categories":"","description":"","excerpt":" This section describes the design of all components of DeNS.\n","ref":"/DeNS/docs/architecture/","tags":"","title":"Design \u0026 Architecture"},{"body":" DeNS Query Layer Development Milestone Outputs\nA package that listens to Cardano transactions that are related to DeNS and populates a relational database. This serves as the main query layer for other applications like DNS analytics (we expect this to be particularly useful for security-related applications) but also as the database from which traditional DNS service integration can take place.\nThe package which listens to Cardano transactions that are related to DeNS and populates a relational database can be found here.\nThe documentation for this package can be found here.\nAcceptance criteria\nThe aforementioned package is able to populate a relational database of DNS records by querying/indexing testnet transactions.\nThe aforementioned package is able to do this as demonstrated in the evidence of milestone completion below.\nEvidence of milestone completion\nLinks to PRs, issues and commits in the DeNS repository where the objectives of the milestone are achieved will be made available so that the Catalyst community and public can review the code.\nThis commit contains the package for the milestone completion.\nVideo demonstration of the use of the package that shows the successful operation of the query layer will be posted on YouTube. A link will be provided to the community in the DeNS repository.\nThe video can be found here.\nNote The video demonstration of the package follows the execution of the integration testsuite which uses plutip to create a disposable private testnet for Cardano transactions. Using plutip permits the integration tests to be reproducibly executed with CI.\n","categories":"","description":"","excerpt":" DeNS Query Layer Development Milestone Outputs\nA package that listens …","ref":"/DeNS/docs/catalyst-reports/milestone-3/","tags":"","title":"Milestone 3"},{"body":" A user who wishes to purchase a domain from the smart contracts may execute the following command to submit a transaction which accomplishes this.\nRegistering a domain dens-transactions-cli \\ register-domain \\ --ogmios-host 127.0.0.1 \\ --ogmios-port 1337 \\ --network Preview \\ --protocol-nft-tx-out-ref \"5969b450ec00019044fbcb1cd5973cc80a47b1507e2e0e14f3e6e4a2f23cdabd#0\" \\ --dens-query-socket-path /ipc/dens-query/dens-query.sock \\ --private-key-bech32 ed25519_sk1p8874wgza2c5yxytucugt2k2mrw3l3gkpg6ezxn498smerqh8j0qe078pu \\ --domain-name mydomain.com ","categories":"","description":"","excerpt":" A user who wishes to purchase a domain from the smart contracts may …","ref":"/DeNS/docs/dens-transactions/register_domain/","tags":"","title":"Register a Domain"},{"body":" After a participant purchases a domain, they have a token whose trading associates RRs with the domain name. The following command demonstrates how one may trade the token so that the provided RRs are associated with the given domain name.\nUpdating the resource records associated with a domain dens-transactions-cli \\ update-record \\ --ogmios-host 127.0.0.1 \\ --ogmios-port 1337 \\ --network Preview \\ --protocol-nft-tx-out-ref \"5969b450ec00019044fbcb1cd5973cc80a47b1507e2e0e14f3e6e4a2f23cdabd#0\" \\ --dens-query-socket-path /ipc/dens-query/dens-query.sock \\ --private-key-bech32 ed25519_sk1p8874wgza2c5yxytucugt2k2mrw3l3gkpg6ezxn498smerqh8j0qe078pu \\ --domain-name mydomain.com \\ --a-record \"270,173.194.202.113\" \\ --soa-record \"30,ns1.mydomain.com dns-admin.mydomain.com 639491960 900 900 1800 60\" Note The RR data stored on the blockchain is passed directly to PowerDNS. So, the syntax of the data must follow what PowerDNS expects. Details can be found in the PowerDNS documentation here Note The PowerDNS authoritative name server uses SOA records in order to identify which backend owns a zone. Thus, for PowerDNS to answer queries, one must include a SOA record for the zone. Details may be found in the PowerDNS documentation here. ","categories":"","description":"","excerpt":" After a participant purchases a domain, they have a token whose …","ref":"/DeNS/docs/dens-transactions/update_record/","tags":"","title":"Update a Record"},{"body":" DeNS Control Layer Development Milestone Outputs\nAn 'offchain' (which is a bit more substantial here than in most dapps) component that can build DeNS transactions and can be exposed to users through CLIs, GUIs, and APIs.\nAn offchain component that can build DeNS transactions exposed via a CLI is provided here.\nMinimally, a basic DeNS CLI utility that can be used to meaningfully interact with the protocol.\nThe CLI utility is provided as a flake output here.\nThe \"meaningful interactions\" with the protocol are described in the documentation here\nAcceptance criteria\nA CLI component using the offchain component is capable of building DeNS transactions and otherwise meaningfully interacting with the protocol (The definition of the phrase “meaningfully interacting” should be clear to the evaluators from design document outputs of the first few milestones).\nEvidence of milestone completion\nA link to a commit where the objectives of the milestone are achieved.\nThis commit includes the offchain component with the aforementioned objectives achieved. In particular, the package provides functionality to build DeNS transactions and interact with the protocol by:\ninitializing the DeNS protocol;\nregistering a domain name with the DeNS protocol; and\nupdating the RRs associated with a domain name.\nThe milestone 5 video demonstrates the CLI in action interacting with the protocol. The video can be found here\n","categories":"","description":"","excerpt":" DeNS Control Layer Development Milestone Outputs\nAn 'offchain' (which …","ref":"/DeNS/docs/catalyst-reports/milestone-4/","tags":"","title":"Milestone 4"},{"body":" Deployment, Documentation, Productionizing Milestone Outputs\nA deployment-ready package or container (Nix/Docker) is made available for users\nSuch packages are all available with Nix as a flake output:\ndens-query-cli\ndens-transactions-cli\ndens-pdns-backend\nDocker images and a Compose file to run the system on the Preview testnet are available here\nExtensive tests, including golden tests where applicable/useful, are implemented for each of the DeNS components\nAn integration test suite which verifies data is piped between each component correctly can be found here\nA test suite for DeNS Query’s to verify the SQL queries function as expected can be found here\nA PowerDNS backend test suite to verify that DeNS Query’s SQL schema integrates with PowerDNS can be found here\nUser-facing documentation \u0026 examples are provided\nA website with user-facing documentation and examples can be found here\nA running service (the exact nature depends on design decisions, provisionally: a DeNS \"local resolver\") that users can integrate with to perform name-resolution queries using our system.\nA running service is demonstrated on the Preview testnet with the Docker images and Compose file mentioned above.\nAcceptance criteria\nThe package / container is properly configured and can be deployed by users to interact with the DeNS protocol.\nThe demo video Preview Testnet Demo Video demonstrates this.\nThe test suites are extensive and all tests pass.\nCI on the most recent commit (at the time of writing this) passes and hence demonstrates that all tests pass.\nDocumentation is clear, thorough, and sufficient for users to interact with the protocol.\nThe project website provided found here has such documentation.\nThe running service actually works.\nThe demo video Preview Testnet Demo Video demonstrates this.\nEvidence of milestone completion\n1-2: A link to a commit where the objectives of the milestone are achieved.\nCommits which demonstrate completion of 1-2 are as follows.\nImplementation of dens-query-cli\nImplementation of dens-transactions-cli\nImplementation of dens-pdns-backend\nDocker images to orchestrate the services\nIntegration test suite\nDeNS Query test suite\nPowerDNS backend test suite\n3: A link to the documentation website.\nThe documentation website can be found here\n4: A demonstration video or set of network logs that clearly show the service in operation.\nThe demo video Preview Testnet Demo Video demonstrates this.\n5: We will show the Cardano community an open-source, well-documented, blockchain-based name resolution service that improves on the privacy and security of DNS.\nEvidence is presented above.\nPreview Testnet Demo Video The video can be found here\nCommands Used The following commands were executed in the demo video.\nNote It is assumed that we start in the root of the project directory. Load all the docker images.\ncd dens-apps/preview-testnet nix build .#cardano-node-preview-testnet-image \u0026\u0026 docker load \u003c ./result nix build .#ogmios-preview-testnet-image \u0026\u0026 docker load \u003c ./result nix build .#dens-query-preview-testnet-image \u0026\u0026 docker load \u003c ./result nix build .#dens-pdns-preview-testnet-image \u0026\u0026 docker load \u003c ./result nix build .#dens-pdns-backend-preview-testnet-image \u0026\u0026 docker load \u003c ./result nix build .#dens-query-postgres-preview-testnet-image \u0026\u0026 docker load \u003c ./result Note These commands were done prior to filming the demo video Run all services using the Compose file.\ndocker compose up Wait several hours for the services to sync with the preview testnet.\nCheck that testdomainname.com has no RRs associated with it using the well known DNS lookup utility dig.\ndig @127.0.0.1 -p 6653 testdomainname.com Important The Compose file maps the port 6653 on the host machine to the PowerDNS server running in the docker image. Purchase the domain name testdomainname.com\ndocker exec -it preview-testnet-dens-query-1 \\ dens-transactions-cli \\ register-domain \\ --ogmios-host ogmios \\ --ogmios-port 1337 \\ --network Preview \\ --protocol-nft-tx-out-ref \"5969b450ec00019044fbcb1cd5973cc80a47b1507e2e0e14f3e6e4a2f23cdabd#0\" \\ --dens-query-socket-path /ipc/dens-query/dens-query.sock \\ --private-key-bech32 ed25519_sk1p8874wgza2c5yxytucugt2k2mrw3l3gkpg6ezxn498smerqh8j0qe078pu \\ --domain-name testdomainname.com Associate testdomainname.com with some RRs\ndocker exec -it preview-testnet-dens-query-1 \\ dens-transactions-cli \\ update-record \\ --ogmios-host ogmios \\ --ogmios-port 1337 \\ --network Preview \\ --protocol-nft-tx-out-ref \"5969b450ec00019044fbcb1cd5973cc80a47b1507e2e0e14f3e6e4a2f23cdabd#0\" \\ --dens-query-socket-path /ipc/dens-query/dens-query.sock \\ --private-key-bech32 ed25519_sk1p8874wgza2c5yxytucugt2k2mrw3l3gkpg6ezxn498smerqh8j0qe078pu \\ --domain-name testdomainname.com \\ --a-record \"270,69.69.69.69\" \\ --soa-record \"30,ns1.testdomainname.com dns-admin.testdomainname.com 639491960 900 900 1800 60\" Verify that testdomainname.com has the RRs we just associated it with.\ndig @127.0.0.1 -p 6653 testdomainname.com Logs The terminal output of the demo is as follows.\n$ dig @127.0.0.1 -p 6653 testdomainname.com ; \u003c\u003c\u003e\u003e DiG 9.18.19 \u003c\u003c\u003e\u003e @127.0.0.1 -p 6653 testdomainname.com ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: SERVFAIL, id: 11316 ;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;testdomainname.com.\tIN\tA ;; Query time: 2 msec ;; SERVER: 127.0.0.1#6653(127.0.0.1) (UDP) ;; WHEN: Wed Jun 05 02:40:22 MDT 2024 ;; MSG SIZE rcvd: 47 $ docker exec -it preview-testnet-dens-query-1 \\ dens-transactions-cli \\ register-domain \\ --ogmios-host ogmios \\ --ogmios-port 1337 \\ --network Preview \\ --protocol-nft-tx-out-ref \"5969b450ec00019044fbcb1cd5973cc80a47b1507e2e0e14f3e6e4a2f23cdabd#0\" \\ --dens-query-socket-path /ipc/dens-query/dens-query.sock \\ --private-key-bech32 ed25519_sk1p8874wgza2c5yxytucugt2k2mrw3l3gkpg6ezxn498smerqh8j0qe078pu \\ --domain-name testdomainname.com (node:136) ExperimentalWarning: Importing JSON modules is an experimental feature and might change at any time (Use `node --trace-warnings ...` to show where the warning was created) info: Tx hash: 9bda385ff825254f416b7c2275e0c4277c6493224ea83163ab724f21a4b6a4da $ docker exec -it preview-testnet-dens-query-1 \\ dens-transactions-cli \\ update-record \\ --ogmios-host ogmios \\ --ogmios-port 1337 \\ --network Preview \\ --protocol-nft-tx-out-ref \"5969b450ec00019044fbcb1cd5973cc80a47b1507e2e0e14f3e6e4a2f23cdabd#0\" \\ --dens-query-socket-path /ipc/dens-query/dens-query.sock \\ --private-key-bech32 ed25519_sk1p8874wgza2c5yxytucugt2k2mrw3l3gkpg6ezxn498smerqh8j0qe078pu \\ --domain-name testdomainname.com \\ --a-record \"270,69.69.69.69\" \\ --soa-record \"30,ns1.testdomainname.com dns-admin.testdomainname.com 639491960 900 900 1800 60\" (node:158) ExperimentalWarning: Importing JSON modules is an experimental feature and might change at any time (Use `node --trace-warnings ...` to show where the warning was created) info: Tx hash: 6414ea74af6ecc214fdac327b5abca8be80f6b9f9dbdb5ec920cedded343a349 $ dig @127.0.0.1 -p 6653 testdomainname.com ; \u003c\u003c\u003e\u003e DiG 9.18.19 \u003c\u003c\u003e\u003e @127.0.0.1 -p 6653 testdomainname.com ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: SERVFAIL, id: 14626 ;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;testdomainname.com.\tIN\tA ;; Query time: 1 msec ;; SERVER: 127.0.0.1#6653(127.0.0.1) (UDP) ;; WHEN: Wed Jun 05 02:42:02 MDT 2024 ;; MSG SIZE rcvd: 47 $ dig @127.0.0.1 -p 6653 testdomainname.com ; \u003c\u003c\u003e\u003e DiG 9.18.19 \u003c\u003c\u003e\u003e @127.0.0.1 -p 6653 testdomainname.com ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: SERVFAIL, id: 5485 ;; flags: qr aa rd; QUERY: 1, ANSWER: 0, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;testdomainname.com.\tIN\tA ;; Query time: 1 msec ;; SERVER: 127.0.0.1#6653(127.0.0.1) (UDP) ;; WHEN: Wed Jun 05 02:42:25 MDT 2024 ;; MSG SIZE rcvd: 47 $ dig @127.0.0.1 -p 6653 testdomainname.com ; \u003c\u003c\u003e\u003e DiG 9.18.19 \u003c\u003c\u003e\u003e @127.0.0.1 -p 6653 testdomainname.com ; (1 server found) ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 13253 ;; flags: qr aa rd; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1 ;; WARNING: recursion requested but not available ;; OPT PSEUDOSECTION: ; EDNS: version: 0, flags:; udp: 1232 ;; QUESTION SECTION: ;testdomainname.com.\tIN\tA ;; ANSWER SECTION: testdomainname.com.\t270\tIN\tA\t69.69.69.69 ;; Query time: 20 msec ;; SERVER: 127.0.0.1#6653(127.0.0.1) (UDP) ;; WHEN: Wed Jun 05 02:42:33 MDT 2024 ;; MSG SIZE rcvd: 63 ","categories":"","description":"","excerpt":" Deployment, Documentation, Productionizing Milestone Outputs\nA …","ref":"/DeNS/docs/catalyst-reports/final-milestone/","tags":"","title":"Final Milestone"},{"body":" This describes the DeNS query component of DeNS. DeNS Query is an HTTP server that syncs with the Cardano blockchain (using Ogmios as an interface to the blockchain) by providing a PostgreSQL database of all UTxOs containing relevant information to the DeNS protocol.\n","categories":"","description":"","excerpt":" This describes the DeNS query component of DeNS. DeNS Query is an …","ref":"/DeNS/docs/dens-query/","tags":"","title":"DeNS Query"},{"body":" This document describes the DeNS transaction component of DeNS. This shows how one can use a CLI interface to create / submit transactions to the Cardano blockchain in order to interact with the DeNS protocol.\n","categories":"","description":"","excerpt":" This document describes the DeNS transaction component of DeNS. This …","ref":"/DeNS/docs/dens-transactions/","tags":"","title":"DeNS Transactions"},{"body":" This section describes dens-pdns-backend-cli which is a PowerDNS backend so RRs on the blockchain can be propagated to traditional DNS resolvers.\n","categories":"","description":"","excerpt":" This section describes dens-pdns-backend-cli which is a PowerDNS …","ref":"/DeNS/docs/dens-pdns-backend/","tags":"","title":"DeNS PowerDNS Integration"},{"body":" This project was graciously funded by the Cardano Treasury in Catalyst Fund 10.\nThe following sections demonstrate evidence of achievement for the project’s milestones.\n","categories":"","description":"","excerpt":" This project was graciously funded by the Cardano Treasury in …","ref":"/DeNS/docs/catalyst-reports/","tags":"","title":"Catalyst reports"},{"body":" This section describes dens-pdns-backend-cli which is a PowerDNS backend so RRs on the blockchain can be propagated to traditional DNS resolvers.\n","categories":"","description":"","excerpt":" This section describes dens-pdns-backend-cli which is a PowerDNS …","ref":"/DeNS/docs/dens-pdns-backend/readme/","tags":"","title":""},{"body":" This describes the DeNS query component of DeNS. DeNS Query is an HTTP server that syncs with the Cardano blockchain (using Ogmios as an interface to the blockchain) by providing a PostgreSQL database of all UTxOs containing relevant information to the DeNS protocol.\n","categories":"","description":"","excerpt":" This describes the DeNS query component of DeNS. DeNS Query is an …","ref":"/DeNS/docs/dens-query/readme/","tags":"","title":""},{"body":" This document describes the DeNS transaction component of DeNS. This shows how one can use a CLI interface to create / submit transactions to the Cardano blockchain in order to interact with the DeNS protocol.\n","categories":"","description":"","excerpt":" This document describes the DeNS transaction component of DeNS. This …","ref":"/DeNS/docs/dens-transactions/readme/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/DeNS/categories/","tags":"","title":"Categories"},{"body":" DeNS: Decentralized Name System Documentation Download A decentralized name system built on the Cardano blockchain\nDeNS is a blockchain-based name resolution service that is an alternative to DNS with much stronger security, transparency, anti-censorship, and anti-centralization guarantees.\n","categories":"","description":"","excerpt":" DeNS: Decentralized Name System Documentation Download A …","ref":"/DeNS/","tags":"","title":"DeNS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/DeNS/tags/","tags":"","title":"Tags"}]